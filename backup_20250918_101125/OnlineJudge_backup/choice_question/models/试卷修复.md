# 改进的考试系统实现方案

## 1. 架构优化建议

### 1.1 统一API设计模式

```python
# api/exam.py - 使用统一的类视图模式

from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from django.db import transaction

class ExamPaperViewSet(viewsets.ModelViewSet):
    """试卷管理ViewSet"""
    serializer_class = ExamPaperSerializer
    queryset = ExamPaper.objects.filter(is_active=True)
    
    @action(detail=True, methods=['post'])
    def generate_preview(self, request, pk=None):
        """生成试卷预览"""
        paper = self.get_object()
        questions = paper.generate_questions()
        # ... 返回预览数据
    
    @action(detail=True, methods=['post'])
    def duplicate(self, request, pk=None):
        """复制试卷"""
        paper = self.get_object()
        new_paper = paper.duplicate()
        return Response(self.get_serializer(new_paper).data)


class ExamSessionViewSet(viewsets.ModelViewSet):
    """考试会话ViewSet"""
    serializer_class = ExamSessionSerializer
    
    def get_queryset(self):
        return ExamSession.objects.filter(user=self.request.user)
    
    @action(detail=True, methods=['post'])
    @transaction.atomic
    def start(self, request, pk=None):
        """开始考试"""
        session = self.get_object()
        if session.status != 'created':
            return Response({'error': '考试已开始或已结束'}, 
                          status=status.HTTP_400_BAD_REQUEST)
        session.start_exam()
        return Response(self.get_serializer(session).data)
    
    @action(detail=True, methods=['post'])
    @transaction.atomic
    def submit_answer(self, request, pk=None):
        """提交单题答案"""
        session = self.get_object()
        # 验证状态和超时
        # 保存答案
        # 返回响应
    
    @action(detail=True, methods=['post'])
    @transaction.atomic
    def submit(self, request, pk=None):
        """提交整张试卷"""
        session = self.get_object()
        session.submit_exam()
        return Response(self.get_serializer(session).data)
```

## 2. 功能增强

### 2.1 添加防作弊机制

```python
class ExamSession(models.Model):
    # 添加防作弊字段
    tab_switches = models.IntegerField(default=0, verbose_name="切换标签次数")
    copy_attempts = models.IntegerField(default=0, verbose_name="复制尝试次数")
    suspicious_behavior = models.JSONField(default=list, verbose_name="可疑行为记录")
    
    def record_tab_switch(self):
        """记录标签切换"""
        self.tab_switches += 1
        self.suspicious_behavior.append({
            'type': 'tab_switch',
            'time': timezone.now().isoformat(),
            'count': self.tab_switches
        })
        self.save()
    
    def check_integrity(self):
        """检查考试完整性"""
        if self.tab_switches > 10:
            return False, "切换标签次数过多"
        if self.copy_attempts > 5:
            return False, "复制尝试次数过多"
        return True, "正常"
```

### 2.2 实时进度保存

```python
class ExamSessionActionAPI(BaseAPIView):
    
    @transaction.atomic
    def post(self, request):
        """自动保存进度"""
        if action == 'auto_save':
            session_id = request.data.get('session_id')
            answers = request.data.get('answers', {})
            
            session = ExamSession.objects.select_for_update().get(
                id=session_id,
                user=request.user
            )
            
            # 批量更新答案
            session.answers.update(answers)
            session.save()
            
            return self.success({
                'saved': True,
                'timestamp': timezone.now().isoformat()
            })
```

### 2.3 考试报告生成

```python
class ExamReportGenerator:
    """考试报告生成器"""
    
    @staticmethod
    def generate_report(session):
        """生成详细的考试报告"""
        questions = ChoiceQuestion.objects.filter(
            id__in=session.questions
        )
        
        report = {
            'basic_info': {
                'paper_title': session.paper.title,
                'student': session.user.username,
                'start_time': session.start_time,
                'submit_time': session.submit_time,
                'duration': session.get_actual_duration(),
                'score': session.score,
                'total_score': session.paper.total_score,
                'correct_rate': f"{session.correct_count}/{session.total_count}"
            },
            'detail_analysis': [],
            'difficulty_analysis': {},
            'category_analysis': {},
            'time_analysis': {
                'average_time_per_question': session.get_avg_time_per_question(),
                'fastest_question': session.get_fastest_question(),
                'slowest_question': session.get_slowest_question()
            }
        }
        
        # 题目详细分析
        for q in questions:
            q_id = str(q.id)
            user_answer = session.answers.get(q_id)
            is_correct = session.is_answer_correct(q, user_answer)
            
            report['detail_analysis'].append({
                'question_id': q.id,
                'question_title': q.title,
                'difficulty': q.difficulty,
                'category': q.category.name if q.category else None,
                'user_answer': user_answer,
                'correct_answer': q.correct_answer,
                'is_correct': is_correct,
                'explanation': q.explanation if not is_correct else None
            })
        
        return report
```

## 3. 前端交互优化

### 3.1 WebSocket实时通信

```python
# consumers.py
import json
from channels.generic.websocket import AsyncWebsocketConsumer

class ExamConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        self.session_id = self.scope['url_route']['kwargs']['session_id']
        self.room_group_name = f'exam_{self.session_id}'
        
        await self.channel_layer.group_add(
            self.room_group_name,
            self.channel_name
        )
        await self.accept()
    
    async def receive(self, text_data):
        data = json.loads(text_data)
        
        if data['type'] == 'heartbeat':
            # 心跳检测，更新在线状态
            await self.send(json.dumps({
                'type': 'heartbeat_ack',
                'remaining_time': self.get_remaining_time()
            }))
        
        elif data['type'] == 'answer':
            # 实时保存答案
            await self.save_answer(data['question_id'], data['answer'])
```

### 3.2 前端状态管理

```javascript
// examStore.js - Vuex状态管理
const examStore = {
    state: {
        session: null,
        questions: [],
        answers: {},
        currentIndex: 0,
        remainingTime: 0,
        autoSaveTimer: null,
        connectionStatus: 'connected'
    },
    
    mutations: {
        SET_SESSION(state, session) {
            state.session = session;
        },
        
        UPDATE_ANSWER(state, { questionId, answer }) {
            Vue.set(state.answers, questionId, answer);
        },
        
        UPDATE_REMAINING_TIME(state, time) {
            state.remainingTime = time;
        }
    },
    
    actions: {
        async startExam({ commit }, paperId) {
            const response = await api.createSession(paperId);
            commit('SET_SESSION', response.data);
            this.dispatch('startAutoSave');
            this.dispatch('startTimer');
        },
        
        startAutoSave({ state }) {
            state.autoSaveTimer = setInterval(() => {
                this.dispatch('saveProgress');
            }, 30000); // 每30秒自动保存
        },
        
        async saveProgress({ state }) {
            if (Object.keys(state.answers).length > 0) {
                await api.autoSave(state.session.id, state.answers);
            }
        }
    }
};
```

## 4. 数据库优化

### 4.1 添加索引

```python
class ExamSession(models.Model):
    class Meta:
        indexes = [
            models.Index(fields=['user', 'status']),
            models.Index(fields=['paper', 'create_time']),
            models.Index(fields=['start_time', 'status']),
        ]
```

### 4.2 查询优化

```python
def get_user_exam_history(user, limit=10):
    """获取用户考试历史（优化版）"""
    return ExamSession.objects.filter(
        user=user,
        status='submitted'
    ).select_related(
        'paper'
    ).prefetch_related(
        'paper__categories',
        'paper__tags'
    ).order_by('-submit_time')[:limit]
```

## 5. 测试用例

```python
# tests/test_exam.py
from django.test import TestCase
from django.contrib.auth import get_user_model
from choice_question.models import ExamPaper, ExamSession

class ExamSystemTestCase(TestCase):
    def setUp(self):
        self.user = get_user_model().objects.create_user(
            username='testuser',
            password='testpass'
        )
        self.paper = ExamPaper.objects.create(
            title='测试试卷',
            duration=60,
            question_count=10,
            created_by=self.user
        )
    
    def test_create_session(self):
        """测试创建考试会话"""
        session = ExamSession.objects.create(
            paper=self.paper,
            user=self.user,
            questions=[1, 2, 3]
        )
        self.assertEqual(session.status, 'created')
    
    def test_start_exam(self):
        """测试开始考试"""
        session = ExamSession.objects.create(
            paper=self.paper,
            user=self.user,
            questions=[1, 2, 3]
        )
        session.start_exam()
        self.assertEqual(session.status, 'started')
        self.assertIsNotNone(session.start_time)
    
    def test_timeout_handling(self):
        """测试超时处理"""
        # 创建并开始考试
        # 模拟超时
        # 验证状态变化
```

## 6. 部署配置

### 6.1 Celery异步任务

```python
# tasks.py
from celery import shared_task
from .models import ExamSession

@shared_task
def check_exam_timeouts():
    """定期检查考试超时"""
    from django.utils import timezone
    
    sessions = ExamSession.objects.filter(
        status='started'
    )
    
    for session in sessions:
        if session.is_timeout():
            session.timeout_exam()
            
@shared_task
def generate_exam_report(session_id):
    """异步生成考试报告"""
    session = ExamSession.objects.get(id=session_id)
    report = ExamReportGenerator.generate_report(session)
    
    # 保存报告或发送邮件
    return report
```

### 6.2 Redis缓存

```python
# 使用Redis缓存热点数据
from django.core.cache import cache

def get_paper_questions(paper_id):
    """获取试卷题目（带缓存）"""
    cache_key = f'paper_questions_{paper_id}'
    questions = cache.get(cache_key)
    
    if not questions:
        paper = ExamPaper.objects.get(id=paper_id)
        questions = paper.generate_questions()
        cache.set(cache_key, questions, 3600)  # 缓存1小时
    
    return questions
```

## 7. 安全性增强

### 7.1 防止重复提交

```python
from django.core.cache import cache
import hashlib

def prevent_duplicate_submission(session_id, user_id):
    """防止重复提交"""
    key = hashlib.md5(f"{session_id}_{user_id}".encode()).hexdigest()
    
    if cache.get(key):
        return False  # 已提交
    
    cache.set(key, True, 300)  # 5分钟内不能重复提交
    return True
```

### 7.2 答案加密存储

```python
from cryptography.fernet import Fernet

class EncryptedAnswerField(models.JSONField):
    """加密的答案字段"""
    
    def __init__(self, *args, **kwargs):
        self.cipher = Fernet(settings.ANSWER_ENCRYPTION_KEY)
        super().__init__(*args, **kwargs)
    
    def pre_save(self, model_instance, add):
        value = super().pre_save(model_instance, add)
        if value:
            encrypted = self.cipher.encrypt(json.dumps(value).encode())
            return encrypted.decode()
        return value
```