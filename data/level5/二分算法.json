[
    {
        "id": "1",
        "type": "single",
        "question": "给定序列:1,3,6,9,17,31,39,52,61,79,81,90,96｡使用以下代码进行二分查找查找元素82时,需要循环多少次,即最后输出的times值为( )?\n<pre><code>int binarySearch(const vector<int>& arr, int target) {\n    int left = 0;\n    int times = 0;\n    int right = arr.size() - 1;\n    while (left <= right) {\n        times++;\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            cout << times << endl;\n            return mid;\n        }\n        else if (arr[mid] < target) {\n            left = mid + 1;\n        }\n        else {\n            right = mid - 1;\n        }\n    }\n    cout << times << endl;\n    return -1;\n}\n</code></pre>",
        "options": ["A. 2", "B. 5", "C. 3", "D. 4"],
        "correct": "D",
        "explanation": "第一次循环：mid=(0+12)/2=6，arr[6]=39<82，left=7；第二次循环：mid=(7+12)/2=9，arr[9]=79<82，left=10；第三次循环：mid=(10+12)/2=11，arr[11]=90>82，right=10；第四次循环：mid=(10+10)/2=10，arr[10]=81<82，left=11，此时left>right，循环结束，times=4。",
        "source": "GESP2024年3月认证C++五级真题.pdf 单选题第8题"
    },
    {
        "id": "2",
        "type": "judge",
        "question": "二分查找要求被搜索的序列是有序的,否则无法保证正确性｡( )",
        "options": ["A. 对", "B. 错"],
        "correct": "A",
        "explanation": "二分查找的基本前提是序列有序，通过每次将搜索区间减半来定位目标元素，无序序列无法保证查找正确性。",
        "source": "GESP2024年3月认证C++五级真题.pdf 判断题第3题"
    },
    {
        "id": "3",
        "type": "single",
        "question": "下面C++代码用于有序list的二分查找,有关说法错误的是( )?\n<pre><code>int _binarySearch(vector<int> lst, int Low, int High, int Target) {\n    if (Low > High)\n        return -1;\n    int Mid = (Low + High) / 2;\n    if (Target == lst[Mid])\n        return Mid;\n    else if (Target < lst[Mid])\n        return _binarySearch(lst, Low, Mid - 1, Target);\n    else\n        return _binarySearch(lst, Mid + 1, High, Target);\n}\nint bSearch(vector<int> lst, int Val) {\n    return _binarySearch(lst, 0, lst.size(), Val);\n}</code></pre>",
        "options": ["A. 代码采用二分法实现有序list的查找", "B. 代码采用分治算法实现有序list的查找", "C. 代码采用递归方式实现有序list的查找", "D. 代码采用动态规划算法实现有序list的查找"],
        "correct": "D",
        "explanation": "代码通过递归实现二分查找，属于分治算法，而非动态规划。动态规划需要保存子问题结果，此处未体现。",
        "source": "GESP2023年12月认证C++五级真题.pdf 单选题第9题"
    },
    {
        "id": "4",
        "type": "single",
        "question": "在上题的_binarySearch算法中,如果lst中有N个元素,其时间复杂度是( )?",
        "options": ["A. O(N)", "B. O(logN)", "C. O(NlogN)", "D. O(N²)"],
        "correct": "B",
        "explanation": "二分查找每次将搜索区间减半，时间复杂度为O(logN)，与元素数量N的对数相关。",
        "source": "GESP2023年12月认证C++五级真题.pdf 单选题第10题"
    },
    {
        "id": "5",
        "type": "single",
        "question": "下列哪个算法并没有体现分治思想?( )",
        "options": ["A. 二分查找", "B. 埃氏筛法", "C. 归并排序", "D. 快速排序"],
        "correct": "B",
        "explanation": "二分查找、归并排序、快速排序均采用分治思想，将问题分解为子问题求解；埃氏筛法通过标记素数倍数筛选素数，未体现分治。",
        "source": "GESP C++ 五级样题.pdf 单选题第14题"
    },
    {
        "id": "6",
        "type": "single",
        "question": "阅读下面C++实现的二分查找代码,下列说法中错误的是( )?\n<pre><code>int binarySearch(int*arr, int l, int r, int x) {\n    if (r >= l) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x)\n            return mid;\n        if (arr[mid] > x)\n            return binarySearch(arr, l, mid - 1, x);\n        return binarySearch(arr, mid + 1, r, x);\n    }\n    return -1;\n}\n</code></pre>",
        "options": ["A. 上面代码实现的二分查找,最少只需查找一次即可得到结果", "B. 如果调用该函数在列表{2, 3, 4, 10, 12}中查找元素0,则它实际被调用3次", "C. 如果调用该函数在列表{2, 3, 4, 10, 12}中查找元素3,则它实际被调用3次", "D. 如果调用该函数在列表{2, 3, 4, 10, 12}中查找元素10,则它实际被调用3次"],
        "correct": "C",
        "explanation": "查找元素3时，第一次mid=2(arr[2]=4>3)，调用左半区；第二次mid=0(arr[0]=2<3)，调用右半区mid=1，找到元素3，共调用2次，而非3次。",
        "source": "GESP C++ 五级样题.pdf 单选题第6题"
    },
    {
        "id": "7",
        "type": "single",
        "question": "关于分治算法,以下哪个说法正确?\n",
        "options": ["A. 分治算法将问题分成子问题,然后分别解决子问题,最后合并结果", "B. 归并排序不是分治算法的应用", "C. 分治算法通常用于解决小规模问题", "D. 分治算法的时间复杂度总是优于O(n log (n))"],
        "correct": "A",
        "explanation": "分治算法的核心是分解子问题并合并结果，归并排序是典型分治应用；分治适用于大规模问题，时间复杂度不一定总优于O(n log n)。",
        "source": "GESP 2024年9月认证 C++ 五级真题.pdf 单选题第12题"
    },
    {
        "id": "8",
        "type": "single",
        "question": "根据下述二分查找法,在排好序的数组1,3,6,9,17,31,39,52,61,79中查找数值31,循环while (left <= right)执行的次数为( )?\n<pre><code>int binary_search(vector<int>& nums, int target) {\n    int left = 0;\n    int right = nums.size() - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) {\n            return mid;\n        }\n        else if (nums[mid] < target) {\n            left = mid + 1;\n        }\n        else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}\n</code></pre>",
        "options": ["A. 1", "B. 2", "C. 3", "D. 4"],
        "correct": "C",
        "explanation": "第一次：mid=4(arr[4]=17<31, left=5)；第二次：mid=7(arr[7]=52>31, right=6)；第三次：mid=5(arr[5]=31，找到)，循环执行3次。",
        "source": "GESP 2024年9月认证 C++ 五级真题.pdf 单选题第13题"
    },
    {
        "id": "9",
        "type": "single",
        "question": "根据下述二分查找法,在排好序的数组1,3,6,9,17,31,39,52,61,79,81,90,96中查找数值82,和82比较的数组元素分别是( )?\n<pre><code>int binary_search(vector<int>& nums, int target) {\n    int left = 0;\n    int right = nums.size() - 1;\n    while (left <= right) {\n        int mid = (left + right) / 2;\n        if (nums[mid] == target) {\n            return mid;\n        }\n        else if (nums[mid] < target) {\n            left = mid + 1;\n        }\n        else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}\n</code></pre>",
        "options": ["A. 52, 61, 81, 90", "B. 52, 79, 90, 81", "C. 39, 79, 90, 81", "D. 39, 79, 90"],
        "correct": "C",
        "explanation": "第一次mid=6(arr[6]=39<82, left=7)；第二次mid=9(arr[9]=79<82, left=10)；第三次mid=11(arr[11]=90>82, right=10)；第四次mid=10(arr[10]=81<82, left=11)，比较元素为39,79,90,81。",
        "source": "2024年6月GESP C++五级真题.pdf 单选题第11题"
    },
    {
        "id": "10",
        "type": "single",
        "question": "给定一个长度为n的有序数组nums,其中可能包含重复元素｡下面的函数返回数组中某个元素target的左边界,若数组中不包含该元素,则返回−1｡例如在数组nums = [5,7,7,8,8,10]中查找target=8,函数返回在数组中的左边界的索引为3｡则横线上应填写的代码为( )?\n<pre><code>int getLeftBoundary(vector<int>& nums, int target) {\n    int left = 0;\n    int right = nums.size() - 1;\n    while (left < right) {\n        int middle = left + ((right - left) / 2);\n        if (target <= nums[middle]) {\n            // 在此处填入代码\n        }\n        else {\n            left = middle + 1;\n        }\n    }\n    return nums[left] == target ? left : -1;\n}\n</code></pre>",
        "options": ["A. right = middle - 1", "B. right = middle", "C. right = middle + 1", "D. 以上都不对"],
        "correct": "B",
        "explanation": "查找左边界时，若target <= nums[middle]，说明左边界在middle或左侧，故right=middle，继续在左半区查找。",
        "source": "GESP 2024年12月认证 C++ 5级真题.pdf 单选题第12题"
    },
    {
        "id": "11",
        "type": "single",
        "question": "若用二分法在[1, 100]内猜数,最多需要猜( )次?\n",
        "options": ["A. 100", "B. 10", "C. 7", "D. 5"],
        "correct": "C",
        "explanation": "2^6=64<100，2^7=128>100，故最多需要7次即可覆盖所有可能。",
        "source": "CCF GESP 2025年3月认证 C++ 5级试题.pdf 单选题第11题"
    }
]