[
  {
    "id": "1",
    "type": "single",
    "question": "与数组相比，链表在( )操作上通常具有更高的效率。",
    "options": [
      "A. 随机访问元素",
      "B. 查找指定元素",
      "C. 在已知位置插入或删除节点",
      "D. 遍历所有元素"
    ],
    "correct": "C",
    "explanation": "数组的插入和删除操作需要移动大量元素，时间复杂度为O(n)；而链表在已知位置（如通过指针定位后）的插入或删除只需修改指针，时间复杂度为O(1)，效率更高。其他选项中，数组在随机访问和遍历效率上更优，两者查找指定元素的效率均为O(n)。",
    "source": "2025年6月 GESP C++五级试题"
  },
  {
    "id": "2",
    "type": "single",
    "question": "下面C++代码实现双向链表。函数is_empty()判断链表是否为空，如链表为空返回true，否则返回false。横线处不能填写( )。",
    "options": [
      "A. return head == nullptr;",
      "B. return tail == nullptr;",
      "C. return head.data == 0;",
      "D. return size == 0;"
    ],
    "correct": "C",
    "explanation": "<pre><code>// 节点结构体 struct Node { int data; Node* prev; Node* next; }; // 双向链表结构体 struct DoubleLink { Node* head; Node* tail; int size; DoubleLink() { head = nullptr; tail = nullptr; size = 0; } ~DoubleLink() { /* 析构函数实现 */ } // 判断链表是否为空 bool is_empty() const { /* 横线处代码 */ } };</code></pre>\n选项C错误，因为head是指向Node的指针，若链表为空，head为nullptr，直接访问head.data会导致空指针异常。其他选项均可正确判断链表是否为空。",
    "source": "2025年6月 GESP C++五级试题"
  },
  {
    "id": "3",
    "type": "single",
    "question": "基于上题代码正确的前提下，填入相应代码完善append()，用于在双向链表尾部增加新节点，横线上应填写( )。",
    "options": [
      "A. tail->next = newNode;",
      "B. newNode->prev = tail; tail = newNode;",
      "C. tail = newNode; newNode->prev = tail; tail->next = newNode;",
      "D. tail->next = newNode; newNode->prev = tail; tail = newNode;"
    ],
    "correct": "D",
    "explanation": "<pre><code>void append(int data) { Node* newNode = new Node{data, nullptr, nullptr}; if (is_empty()) { head = tail = newNode; } else { // 横线处代码 } ++size; }</code></pre>\n在尾部插入新节点时，需依次执行：\n1. 将当前尾节点的next指向新节点；\n2. 将新节点的prev指向当前尾节点；\n3. 更新尾节点为新节点。\n选项D按此顺序操作，确保链表指针关系正确。",
    "source": "2025年6月 GESP C++五级试题"
  },
  {
    "id": "4",
    "type": "single",
    "question": "下列C++代码用循环链表解决约瑟夫问题，即假设n个人围成一圈，从第一个人开始数，每次数到第k个的人就出圈，输出最后留下的那个人的编号。横线上应填写( )。",
    "options": [
      "A. p = prev->next; delete p; prev->next = p->next;",
      "B. prev->next = p->next; delete p; p = prev->next;",
      "C. p = prev->next; delete p; prev->next = p->next;",
      "D. prev->next = p->next; p = prev->next; delete p;"
    ],
    "correct": "B",
    "explanation": "<pre><code>struct Node { int data; Node* next; }; Node* createCircularList(int n) { /* 创建循环链表 */ } int findLastSurvival(int n, int k) { Node* head = createCircularList(n); Node* p = head; Node* prev = nullptr; while (p->next != p) { for (int count = 1; count < k; ++count) { prev = p; p = p->next; } // 横线处代码 } cout << \"最后留下的人编号是: \" << p->data << endl; return 0; }</code></pre>\n删除第k个节点时，需先将prev的next指向p的next（跳过p），再删除p，最后更新p为prev的next以继续循环。选项B符合此逻辑，确保链表循环不中断。",
    "source": "2025年6月 GESP C++五级试题"
  },
  {
    "id": "5",
    "type": "single",
    "question": "下列C++代码判断一个正整数是否是质数，说法正确的是( )。",
    "options": [
      "A. 代码存在错误，比如5是质数，但因为5 % 5余数是0返回了false",
      "B. finish_number的值应该是n / 2，当前写法将导致错误",
      "C. 当前while循环正确的前提是：所有大于3的质数都符合6k±1形式",
      "D. while循环修改如下，其执行效果和执行时间相同。for (int i = 2; i < finish_number; i++) { if (n % i == 0) return false; return true; }"
    ],
    "correct": "C",
    "explanation": "<pre><code>bool is_prime(int n) { if (n <= 1) return false; if (n == 2 || n == 3 || n == 5) return true; if (n % 2 == 0 || n % 3 == 0 || n % 5 == 0) return false; int i = 7; int step = 4; int finish_number = sqrt(n) + 1; while (i <= finish_number) { if (n % i == 0) return false; i += step; step = 6 - step; } return true; }</code></pre>\n代码优化基于数学结论：大于3的质数必为6k±1（k为整数），因此循环中i从7开始，步长交替为4和2（即6k-1和6k+1）。选项C正确，其他选项均存在逻辑错误。",
    "source": "2025年6月 GESP C++五级试题"
  },
  {
    "id": "6",
    "type": "single",
    "question": "下列C++代码用两种方式求解两个正整数的最大公约数，说法错误的是( )。",
    "options": [
      "A. gcd0()函数的时间复杂度为O(log min(a, b))",
      "B. gcd1()函数的时间复杂度为O(min(a, b))",
      "C. 一般说来，gcd0()的效率高于gcd1()",
      "D. gcd1()中的代码for (int i = small; i >= 1; --i)应该修改为for (int i = small; i > 1; --i)"
    ],
    "correct": "D",
    "explanation": "<pre><code>int gcd0(int big, int small) { if (big < small) swap(big, small); if (big % small == 0) return small; return gcd0(small, big % small); } int gcd1(int big, int small) { if (big < small) swap(big, small); for (int i = small; i >= 1; --i) { if (big % i == 0 && small % i == 0) return i; } return 1; }</code></pre>\n选项D错误，因为1是所有整数的公约数，若循环条件改为i > 1，当两数互质时会遗漏i=1的情况，导致返回错误结果。gcd1()的循环必须包含i=1。",
    "source": "2025年6月 GESP C++五级试题"
  },
  {
    "id": "7",
    "type": "single",
    "question": "下面的代码用于判断整数是否是质数，错误的说法是( )。",
    "options": [
      "A. 埃氏筛算法相对于上面的代码效率更高",
      "B. 线性筛算法相对于上面的代码效率更高",
      "C. 上面的代码有很多重复计算，因为不是判断单个数是否为质数，故而导致筛选出连续数中质数的效率不高",
      "D. 相对而言，埃氏筛算法比上面代码以及线性筛算法效率都高"
    ],
    "correct": "D",
    "explanation": "<pre><code>bool is_prime(int n) { if (n <= 1) return false; int finish_number = static_cast<int>(sqrt(n)) + 1; for (int i = 2; i < finish_number; ++i) { if (n % i == 0) return false; } return true; }</code></pre>\n线性筛算法的时间复杂度为O(n)，优于埃氏筛的O(n log log n)，因此选项D中“埃氏筛比线性筛效率高”的说法错误。其他选项均正确描述了各算法的效率特点。",
    "source": "2025年6月 GESP C++五级试题"
  },
  {
    "id": "8",
    "type": "single",
    "question": "唯一分解定理描述了关于正整数的什么性质?",
    "options": [
      "A. 任何正整数都可以表示为两个素数的和。",
      "B. 任何大于1的合数都可以唯一分解为有限个质数的乘积。",
      "C. 两个正整数的最大公约数总是等于它们的最小公倍数除以它们的乘积。",
      "D. 所有素数都是奇数。"
    ],
    "correct": "B",
    "explanation": "唯一分解定理（算术基本定理）指出：任何大于1的自然数要么是质数，要么可以唯一地分解为有限个质数的乘积（不考虑顺序）。选项B正确，其他选项均与定理内容不符。",
    "source": "2025年6月 GESP C++五级试题"
  },
  {
    "id": "9",
    "type": "single",
    "question": "下面的C++代码，用于求一系列数据中的最大值。有关其算法说法错误的是( )。",
    "options": [
      "A. 该算法采用分治算法",
      "B. 该算法是递归实现",
      "C. 该算法采用贪心算法",
      "D. 该算法不是递推算法"
    ],
    "correct": "C",
    "explanation": "<pre><code>int find_max_recursive(const vector<int>& nums, int left, int right) { if (left == right) return nums[left]; int mid = left + (right - left) / 2; int left_max = find_max_recursive(nums, left, mid); int right_max = find_max_recursive(nums, mid + 1, right); return max(left_max, right_max); } int find_max(const vector<int>& nums) { /* 调用递归函数 */ }</code></pre>\n该算法通过分治策略（将数组分为两半，递归求最大值后合并）实现，未采用贪心算法（贪心强调局部最优选择）。选项C的说法错误，其他选项均正确。",
    "source": "2025年6月 GESP C++五级试题"
  },
  {
    "id": "10",
    "type": "single",
    "question": "下面的C++代码，用于求一系列数据中的最大值。有关其算法说法错误的是( )。",
    "options": [
      "A. 本题find_max()函数采用的是迭代算法",
      "B. 本题find_max()函数的时间复杂度为O(log n)",
      "C. 和上一题的find_max()相比，因为没有递归，所以没有栈的创建和销毁开销",
      "D. 本题find_max()函数和上一题的find_max()时间复杂度相同"
    ],
    "correct": "B",
    "explanation": "<pre><code>int find_max(const vector<int>& nums) { if (nums.empty()) { throw invalid_argument(\"输入数组不能为空\"); } int max_value = nums[0]; for (int num : nums) { if (num > max_value) { max_value = num; } } return max_value; }</code></pre>\n该迭代算法需遍历所有元素，时间复杂度为O(n)，而非O(log n)。选项B的说法错误，其他选项均正确。",
    "source": "2025年6月 GESP C++五级试题"
  },
  {
    "id": "11",
    "type": "single",
    "question": "下面的C++代码用于在升序数组lst中查找目标值target最后一次出现的位置。相关说法，正确的是( )。",
    "options": [
      "A. 当lst中存在重复的target时，该函数总能返回最后一个target的位置，即便lst全由相同元素组成",
      "B. 当target小于lst中所有元素时，该函数会返回0",
      "C. 循环条件改为while (low <= high)程序执行效果相同，且能提高准确性",
      "D. 将代码中(low + high + 1) / 2修改为(low + high) / 2效果相同"
    ],
    "correct": "A",
    "explanation": "<pre><code>int binary_search_last_occurrence(const vector<int>& lst, int target) { if (lst.empty()) return -1; int low = 0, high = lst.size() - 1; while (low < high) { int mid = (low + high + 1) / 2; if (lst[mid] <= target) { low = mid; } else { high = mid - 1; } } return lst[low] == target ? low : -1; }</code></pre>\n代码通过调整mid计算（加1避免死循环）和条件判断，确保找到最后一个target。选项A正确，即使数组全为target，也能返回最后一个索引。其他选项均存在逻辑错误。",
    "source": "2025年6月 GESP C++五级试题"
  },
  {
    "id": "12",
    "type": "single",
    "question": "有关下面C++代码的说法，错误的是( )。",
    "options": [
      "A. “阶段1”的目标是寻找正整数n可能的正完全平方根",
      "B. “阶段2”的目标是如果正整数n没有正完全平方根，则在可能产生完全平方根附近寻找带小数点的平方根",
      "C. 代码check_int = (long long)(result + 0.5)是检查因浮点误差是否为正完全平方根",
      "D. 阶段2的二分法中high_d - low_d >= epsilon不能用于浮点数比较，会进入死循环"
    ],
    "correct": "D",
    "explanation": "<pre><code>double sqrt_binary(long long n, double epsilon = 1e-10) { if (n < 0) throw; if (n == 0 || n == 1) return n; // 阶段1：查找整数平方根 long long low = 1, high = n, k = 0; while (low <= high) { /* 查找k使得k² <= n < (k+1)² */ } // 阶段2：二分法求精确值 double low_d = k, high_d = k + 1; while (high_d - low_d >= epsilon) { /* 二分迭代 */ } /* 检查是否为完全平方数 */ return result; }</code></pre>\n浮点数比较中，使用epsilon（如1e-10）判断精度是常见方法，可避免因浮点误差导致的死循环。选项D的说法错误，其他选项均正确。",
    "source": "2025年6月 GESP C++五级试题"
  },
  {
    "id": "13",
    "type": "single",
    "question": "硬币找零问题中要求找给客户最少的硬币。coins存储可用硬币规格，单位为角，假设规格都小于10角，且一定有1角规格。amount为要找零的金额，约定必须为1角的整数倍。输出为每种规格及其数量，按规格从大到小输出，如果某种规格不必要，则输出为0。下面是其实现代码，相关说法正确的是( )。",
    "options": [
      "A. 上述代码采用贪心算法实现",
      "B. 针对本题具体要求，上述代码总能找到最优解",
      "C. 上述代码采用枚举算法",
      "D. 上述代码采用分治算法"
    ],
    "correct": "A",
    "explanation": "<pre><code>const int MAX_COINS = 10; int result[MAX_COINS] = {0}; int find_coins(const vector<int>& coins, int amount) { sort(coins.begin(), coins.end(), greater<int>()); int n = coins.size(); for (int i = 0; i < n; ++i) { int coin = coins[i]; int num = amount / coin; result[i] = num; amount -= num * coin; if (amount == 0) break; } /* 输出结果 */ return 0; }</code></pre>\n代码采用贪心策略：优先使用最大面额硬币，逐步减少金额，符合贪心算法的特征。选项A正确。但需注意，贪心算法并非对所有硬币系统都能得到最优解，本题因存在1角硬币，可保证结果正确，但选项B的“总能”表述不准确（题目限定了硬币规格）。",
    "source": "2025年6月 GESP C++五级试题"
  },
  {
    "id": "14",
    "type": "single",
    "question": "关于下述C++代码的快速排序算法，说法错误的是( )。",
    "options": [
      "A. 在randomPartition函数中，变量i的作用是记录大于基准值的元素的边界",
      "B. randomPartition函数随机选择基准值，可以避免输入数据特定模式导致的最坏情况下时间复杂度O(n²)",
      "C. 快速排序平均时间复杂度是O(n log n)",
      "D. 快速排序是稳定排序算法"
    ],
    "correct": "D",
    "explanation": "<pre><code>int randomPartition(vector<int>& arr, int low, int high) { int random = low + rand() % (high - low + 1); swap(arr[random], arr[high]); int pivot = arr[high]; int i = low - 1; for (int j = low; j < high; j++) { if (arr[j] <= pivot) { i++; swap(arr[i], arr[j]); } } swap(arr[i + 1], arr[high]); return i + 1; } void quickSort(vector<int>& arr, int low, int high) { /* 递归排序 */ }</code></pre>\n快速排序在交换元素时可能改变相同元素的相对顺序，因此是不稳定排序。选项D的说法错误，其他选项均正确。",
    "source": "2025年6月 GESP C++五级试题"
  },
  {
    "id": "15",
    "type": "single",
    "question": "小杨编写了一个如下的高精度除法函数，则横线上应填写的代码为( )。",
    "options": [
      "A. r.d[0] = a.d[i]; r.len++;",
      "B. r.d[i] = a.d[i]; r.len++;",
      "C. r.d[i] = a.d[i]; r.len = 1;",
      "D. r.d[0] = a.d[i]; r.len = 1;"
    ],
    "correct": "A",
    "explanation": "<pre><code>struct BigInt { int d[MAXN]; int len; BigInt() { memset(d, 0, sizeof(d)); len = 0; } }; pair<BigInt, BigInt> div(BigInt a, BigInt b) { BigInt q, r; if (compare(a, b) < 0) { /* 商为0，余数为a */ } // 初始化余数r为a的前b.len位 r.len = b.len; for (int i = a.len - 1; i >= a.len - b.len; i--) { r.d[i - (a.len - b.len)] = a.d[i]; } // 逐位计算商 for (int i = a.len - b.len; i >= 0; i--) { if (r.len > 1 || r.d[0] != 0) { for (int j = r.len; j > 0; j--) { r.d[j] = r.d[j-1]; } } else { // 横线处代码 } /* 计算当前位的商 */ } return {q, r}; }</code></pre>\n当余数r为空时，需将a的第i位作为新余数的第0位，长度设为1。选项A正确，确保余数格式正确（低位在前）。",
    "source": "2025年6月 GESP C++五级试题"
  },
  {
    "id": "16",
    "type": "single",
    "question": "下面C++代码是用欧几里得算法（辗转相除法）求两个正整数的最大公约数，a大于b还是小于b都适用。",
    "options": [
      "A. 正确",
      "B. 错误"
    ],
    "correct": "A",
    "explanation": "<pre><code>int gcd(int a, int b) { while (b) { int temp = b; b = a % b; a = temp; } return a; }</code></pre>\n代码中，无论a最初是否大于b，通过循环中的取余和赋值操作，会自动调整a和b的大小（使a始终为较大数），因此适用于a大于或小于b的情况。说法正确。",
    "source": "2025年6月 GESP C++五级试题"
  },
  {
    "id": "17",
    "type": "single",
    "question": "假设函数gcd()函数能正确求两个正整数的最大公约数，则下面的lcm()函数能求相应两数的最小公倍数。",
    "options": [
      "A. 正确",
      "B. 错误"
    ],
    "correct": "A",
    "explanation": "<pre><code>int lcm(int a, int b) { return a * b / gcd(a, b); }</code></pre>\n根据数学关系，两个正整数的最小公倍数 = 两数乘积 / 最大公约数。在不发生溢出的情况下，该函数正确。说法正确。",
    "source": "2025年6月 GESP C++五级试题"
  },
  {
    "id": "18",
    "type": "single",
    "question": "下面的C++代码用于输出每个数对[2, m]的质因数分解。",
    "options": [
      "A. 正确",
      "B. 错误"
    ],
    "correct": "B",
    "explanation": "<pre><code>int main() { int n, m; cin >> n >> m; if (n > m) swap(n, m); map<int, vector<int>> prime_factor; for (int i = n; i <= m; ++i) { int j = 2, k = i; while (k != 1) { if (k % j == 0) { prime_factor[i].push_back(j); k /= j; } else { j++; } } } /* 输出结果 */ return 0; }</code></pre>\n代码中，当k为质数时，j会遍历到k才找到除数，效率低但逻辑正确。但题目中“数对[2, m]”表述不清晰，且代码实际处理的是[n, m]范围的数，存在歧义。更关键的是，代码未初始化prime_factor[i]，可能导致未定义行为。因此说法错误。",
    "source": "2025年6月 GESP C++五级试题"
  },
  {
    "id": "19",
    "type": "single",
    "question": "下面的C++代码实现归并排序。代码在执行时，将输出一次HERE字符串，因为merge()函数仅被调用一次。",
    "options": [
      "A. 正确",
      "B. 错误"
    ],
    "correct": "B",
    "explanation": "<pre><code>void merge(vector<int>& arr, int left, int mid, int right) { /* 合并操作 */ } void mergeSort(vector<int>& arr, int left, int right) { if (left >= right) return; int mid = (left + right) / 2; mergeSort(arr, left, mid); mergeSort(arr, mid + 1, right); cout << \"HERE\"; merge(arr, left, mid, right); }</code></pre>\n归并排序中，merge()函数的调用次数为n-1（n为数组长度），因此会多次输出HERE，而非一次。说法错误。",
    "source": "2025年6月 GESP C++五级试题"
  },
  {
    "id": "20",
    "type": "single",
    "question": "归并排序的最好、最坏和平均时间复杂度均为O(n log n)。",
    "options": [
      "A. 正确",
      "B. 错误"
    ],
    "correct": "A",
    "explanation": "归并排序采用分治策略，无论输入数据是否有序，都将数组分为两半并递归排序，最后合并，时间复杂度稳定为O(n log n)。说法正确。",
    "source": "2025年6月 GESP C++五级试题"
  },
  {
    "id": "21",
    "type": "single",
    "question": "查字典这个小学生必备技能，可以把字典视为一个已排序的数组。假设小杨要查找一个音首字母为g的单词，他首先翻到字典约一半的页数，发现该页的首字母是m，由于字母表中g位于m之前，所以排除字典后半部分，查找范围缩小到前半部分；不断重复上述步骤，直至找到首字母为g的页码。这种查字典的一系列操作可看作二分查找。",
    "options": [
      "A. 正确",
      "B. 错误"
    ],
    "correct": "A",
    "explanation": "二分查找的核心是每次将查找范围缩小一半，与查字典时通过中间位置判断并缩小范围的过程一致。说法正确。",
    "source": "2025年6月 GESP C++五级试题"
  },
  {
    "id": "22",
    "type": "single",
    "question": "求解下图中A点到D点最短路径，其中A到B之间的距离为12。求解这样的问题常用Dijkstra算法，其思路是通过逐步选择当前距离起点最近的节点来求解非负权重图（如距离不能为负值）单源最短路径的算法。从该算法的描述可以看出，Dijkstra算法是贪心算法。",
    "options": [
      "A. 正确",
      "B. 错误"
    ],
    "correct": "A",
    "explanation": "Dijkstra算法每次选择当前距离起点最近的未访问节点，更新其邻接节点的距离，属于贪心策略（局部最优选择）。说法正确。",
    "source": "2025年6月 GESP C++五级试题"
  },
  {
    "id": "23",
    "type": "single",
    "question": "分治算法将原问题可以分解成规模更小的子问题，使得求解问题的难度降低。但由于分治算法需要将问题进行分解，并且需要将多个子问题的解合并为原问题的解，所以分治算法的效率通常比直接求解原问题的效率低。",
    "options": [
      "A. 正确",
      "B. 错误"
    ],
    "correct": "B",
    "explanation": "分治算法通过将问题分解为子问题，通常能降低时间复杂度（如归并排序O(n log n)优于简单排序O(n²)）。虽然存在分解和合并的开销，但整体效率更高。说法错误。",
    "source": "2025年6月 GESP C++五级试题"
  },
  {
    "id": "24",
    "type": "single",
    "question": "函数puzzle定义如下，则调用puzzle(7)程序会无限递归。",
    "options": [
      "A. 正确",
      "B. 错误"
    ],
    "correct": "B",
    "explanation": "<pre><code>int puzzle(int n) { if (n == 1) return 1; if (n % 2 == 0) return puzzle(n / 2); return puzzle(3 * n + 1); }</code></pre>\n调用puzzle(7)的递归链为：7 → 22 → 11 → 34 → 17 → 52 → 26 → 13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1，最终终止于n=1，不会无限递归。说法错误。",
    "source": "2025年6月 GESP C++五级试题"
  },
  {
    "id": "25",
    "type": "single",
    "question": "如下为线性筛法，用于高效生成素数表，其核心思想是每个合数只被它的最小质因数筛掉一次，时间复杂度为O(n)。",
    "options": [
      "A. 正确",
      "B. 错误"
    ],
    "correct": "A",
    "explanation": "<pre><code>vector<int> linearSieve(int n) { vector<bool> is_prime(n + 1, true); vector<int> primes; is_prime[0] = is_prime[1] = false; for (int i = 2; i <= n; ++i) { if (is_prime[i]) primes.push_back(i); for (int j = 0; j < primes.size() && i * primes[j] <= n; ++j) { is_prime[i * primes[j]] = false; if (i % primes[j] == 0) break; } } return primes; }</code></pre>\n线性筛法通过确保每个合数仅被其最小质因数标记，避免重复操作，时间复杂度为O(n)。说法正确。",
    "source": "2025年6月 GESP C++五级试题"
  }
]