[
    {
        "id": "1",
        "type": "single",
        "question": "归并排序的基本思想是( )?",
        "options": ["A. 将数组分成两个子数组,分别排序后再合并", "B. 随机选择一个元素作为枢轴,将数组划分为两个部分", "C. 从数组的最后一个元素开始,依次与前一个元素比较并交换位置", "D. 比较相邻的两个元素,如果顺序错误就交换位置"],
        "correct": "A",
        "explanation": "归并排序采用分治策略，先将数组分为两个子数组，递归排序后再合并，A正确。B描述的是快速排序，C和D是冒泡排序的思想。",
        "source": "GESP2024年3月认证C++五级真题.pdf 单选题第14题"
    },
    {
        "id": "2",
        "type": "single",
        "question": "分治算法的核心思想是将一个大问题分解成多个相同或相似的子问题进行解决,最后合并得到原问题的解｡( )",
        "options": ["A. 对", "B. 错"],
        "correct": "A",
        "explanation": "分治算法的定义就是分解子问题、求解子问题、合并结果，符合描述，正确。",
        "source": "GESP2024年3月认证C++五级真题.pdf 判断题第5题"
    },
    {
        "id": "3",
        "type": "single",
        "question": "下面C++代码以递归方式实现合并排序,并假设merge(int T[], int R[], int s, int m, int t)函数将有序的T[s..m]和T[m+1..t]归并到R[s..t]中｡横线处应填上代码是( )?\n<pre><code>void mergeSort(int SList[],int TList[],int s,int t,int len) {\n    if(s==t) {\n        TList[s] = SList[s];\n        return;\n    }\n    int*T2 = new int[len];//保存中间结果\n    int m = (s + t) / 2;\n    // 在此处填入代码\n    merge(T2, SList, s, m, t);\n    delete T2;\n    return ;\n}</code></pre>",
        "options": ["A. mergeSort(SList, T2, s, m, len), mergeSort(SList, T2, m, t, len)", "B. mergeSort(SList, T2, s, m-1, len), mergeSort(SList, T2, m+1, t, len)", "C. mergeSort(SList, T2, s, m, len), mergeSort(SList, T2, m+1, t, len)", "D. mergeSort(SList, T2, s, m-1, len), mergeSort(SList, T2, m-1, t, len)"],
        "correct": "C",
        "explanation": "归并排序需要将数组分为左右两部分递归排序，左半区是[s, m]，右半区是[m+1, t]，所以调用mergeSort处理这两个区间，C正确。",
        "source": "GESP2023年12月认证C++五级真题.pdf 单选题第2题"
    },
    {
        "id": "4",
        "type": "single",
        "question": "下面的C++代码实现对list的快速排序,有关说法,错误的是( )?\n<pre><code>vector<int> operator +(vector<int> lA, vector<int> lB) {\n    vector<int> lst;\n    for (int i = 1; i < lA.size(); i++)\n        lst.push_back(lA[i]);\n    for (int i = 1; i < lB.size(); i++)\n        lst.push_back(lB[i]);\n    return lst;\n}\nvector<int> qSort(vector<int> lst) {\n    if (lst.size() < 2)\n        return lst;\n    int pivot = lst[0];\n    vector<int> less, greater;\n    for (int i = 1; i < lst.size(); i++)\n        if (lst[i] <= pivot)\n            less.push_back(lst[i]);\n        else\n            greater.push_back(lst[i]);\n    for (int i = 1; i < lst.size(); i++)\n        if (lst[i] <= pivot)\n            less.push_back(lst[i]);\n        else\n            greater.push_back(lst[i]);\n    return \n}</code></pre>",
        "options": ["A. qSort(less) + qSort(greater) + (vector<int>)pivot", "B. (vector<int>)pivot + (qSort(less) + qSort(greater))", "C. (qSort(less) + (vector<int>)pivot + qSort(greater))", "D. qSort(less) + pivot + qSort(greater)"],
        "correct": "C",
        "explanation": "快速排序的正确分区是将小于基准的元素、基准、大于基准的元素合并，所以顺序是qSort(less) + pivot + qSort(greater)，C正确。",
        "source": "GESP2023年12月认证C++五级真题.pdf 单选题第7题"
    },
    {
        "id": "5",
        "type": "single",
        "question": "归并排序的时间复杂度是O(N logN)｡( )",
        "options": ["A. 对", "B. 错"],
        "correct": "A",
        "explanation": "归并排序的时间复杂度在最好、最坏和平均情况下都是O(n log n)，正确。",
        "source": "GESP2023年12月认证C++五级真题.pdf 判断题第1题"
    },
    {
        "id": "6",
        "type": "single",
        "question": "下面代码用于归并排序,其中merge()函数被调用次数为( )?\n<pre><code>#include <iostream>\nusing namespace std;\nvoid mergeSort(int*listData,int start,int end);\nvoid merge(int*listData,int start,int middle,int end);\nvoid mergeSort(int*listData, int start,int end) {\n    if(start >= end)\n        return;\n    int middle = (start + end) / 2;\n    mergeSort(listData, start, middle);\n    mergeSort(listData, middle + 1, end);\n    merge(listData, start, middle, end);\n}\nvoid merge(int*listData,int start,int middle,int end) {\n    int leftSize = middle - start + 1;\n    int rightSize = end - middle;\n    int*left = new int[leftSize];\n    int*right = new int[rightSize];\n    for (int i = 0; i < leftSize; i++)\n        left[i] = listData[start + i];\n    for (int j = 0; j < rightSize; j++)\n        right[j] = listData[middle + 1 + j];\n    int i = 0, j = 0, k = start;\n    while (i < leftSize && j < rightSize) {\n        if (left[i] <= right[j]) {\n            listData[k] = left[i];\n            i++;\n        } else {\n            listData[k] = right[j];\n            j++;\n        }\n        k++;\n    }\n    while (i < leftSize)\n        listData[k++] = left[i++];\n    while (j < rightSize)\n        listData[k++] = right[j++];\n    delete[] left;\n    delete[] right;\n}\nint main() {\n    int lstA[] = {1, 3, 2, 7, 11, 5, 3};\n    int size = sizeof(lstA) / sizeof(lstA[0]);\n    mergeSort(lstA, 0, size - 1);\n    for (int i = 0; i < size; i++)\n        cout << lstA[i] << \" \";\n    cout << endl;\n    return 0;\n}\n</code></pre>",
        "options": ["A. 0", "B. 1", "C. 6", "D. 7"],
        "correct": "C",
        "explanation": "归并排序的merge调用次数与递归深度有关，对于n=7个元素，递归树的层数为log2(7)≈3，每层的merge次数分别为4, 2, 1，总次数为4+2+1=7？不，实际对于n=7，分解为3和3，然后分解为1和2，1和1，2分解为1和1，合并次数为3（第一层）+2（第二层）+1（第三层）=6次，C正确。",
        "source": "GESP2023年9月认证C++五级真题.pdf 单选题第12题"
    },
    {
        "id": "7",
        "type": "single",
        "question": "在上题的归并排序算法中,mergeSort(listData, start, middle);和mergeSort(listData, middle + 1, end);涉及到的算法为( )?",
        "options": ["A. 搜索算法", "B. 分治算法", "C. 贪心算法", "D. 递推算法"],
        "correct": "B",
        "explanation": "归并排序是典型的分治算法应用，通过分解问题为子问题并合并，B正确。",
        "source": "GESP2023年9月认证C++五级真题.pdf 单选题第13题"
    },
    {
        "id": "8",
        "type": "single",
        "question": "归并排序算法的基本思想是( )?",
        "options": ["A. 将数组分成两个子数组,分别排序后再合并", "B. 随机选择一个元素作为枢轴,将数组划分为两个部分", "C. 从数组的最后一个元素开始,依次与前一个元素比较并交换位置", "D. 比较相邻的两个元素,如果顺序错误就交换位置"],
        "correct": "A",
        "explanation": "归并排序的核心是分治合并，A正确；B是快速排序，C和D是冒泡排序。",
        "source": "GESP2023年9月认证C++五级真题.pdf 单选题第14题"
    },
    {
        "id": "9",
        "type": "single",
        "question": "下面C++代码用于排序,下列说法中错误的是( )?\n<pre><code>void sortA(int*arr, int n) {\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n - i - 1; ++j) {\n            if (arr[j] > arr[j + 1]) {\n                int tmp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = tmp;\n            }\n        }\n    }\n}\nvoid sortB(int*arr, int start, int end) {\n    if (start >= end)\n        return;\n    int middle = (start + end) / 2;\n    sortB(arr, start, middle);\n    sortB(arr, middle + 1, end);\n    int leftSize = middle - start + 1;\n    int rightSize = end - middle;\n    int*left = new int[leftSize];\n    int*right = new int[rightSize];\n    for (int i = 0; i < leftSize; i++)\n        left[i] = arr[start + i];\n    for (int j = 0; j < rightSize; j++)\n        right[j] = arr[middle + 1 + j];\n    int i = 0, j = 0, k = start;\n    while (i < leftSize && j < rightSize) {\n        if (left[i] <= right[j])\n            arr[k++] = left[i++];\n        else\n            arr[k++] = right[j++];\n    }\n    while (i < leftSize)\n        arr[k++] = left[i++];\n    while (j < rightSize)\n        arr[k++] = right[j++];\n    delete[] left;\n    delete[] right;\n}\n</code></pre>",
        "options": ["A. 两种排序算法的时间复杂度不同", "B. 两种排序算法的空间复杂度一致", "C. sortA的时间复杂度在最好和最坏情况下都是O(n²)", "D. sortB的平均时间复杂度、最好情况的时间复杂度都是O(n log n)，最坏情况的时间复杂度是O(n²)"],
        "correct": "B",
        "explanation": "sortA是冒泡排序，空间复杂度O(1)；sortB是归并排序，空间复杂度O(n)，两者空间复杂度不同，B错误。",
        "source": "GESP C++ 五级样题.pdf 单选题第12题"
    },
    {
        "id": "10",
        "type": "single",
        "question": "上一题中的`sortB`函数,明显体现出的算法思想和编程方法包括( )?",
        "options": ["A. 递归", "B. 分治", "C. A、B都正确", "D. A、B都不正确"],
        "correct": "C",
        "explanation": "sortB通过递归实现分治策略，先分解数组再合并，同时使用递归调用，C正确。",
        "source": "GESP C++ 五级样题.pdf 单选题第13题"
    },
    {
        "id": "11",
        "type": "single",
        "question": "假设快速排序算法的输入是一个长度为n的已排序数组,且该快速排序算法在分治过程总是选择第一个元素作为基准元素｡下面选项( )描述的是在这种情况下的快速排序行为?",
        "options": ["A. 快速排序对于此类输入的表现最好,因为数组已经排序", "B. 快速排序对于此类输入的时间复杂度是O(n log n)", "C. 快速排序对于此类输入的时间复杂度是O(n²)", "D. 快速排序无法对此类数组进行排序,因为数组已经排序"],
        "correct": "C",
        "explanation": "当快速排序选择第一个元素作为基准且数组已排序时，每次分区会导致一个子数组为空，时间复杂度退化为O(n²)，C正确。",
        "source": "GESP 2024年9月认证 C++ 五级真题.pdf 单选题第9题"
    },
    {
        "id": "12",
        "type": "single",
        "question": "考虑以下C++代码实现的归并排序算法:\n<pre><code>void merge(int arr[], int left, int mid, int right) {\n    int n1 = mid - left + 1;\n    int n2 = right - mid;\n    int L[n1], R[n2];\n    for (int i = 0; i < n1; i++)\n        L[i] = arr[left + i];\n    for (int j = 0; j < n2; j++)\n        R[j] = arr[mid + 1 + j];\n    int i = 0, j = 0, k = left;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        } else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n    while (i < n1)\n        arr[k++] = L[i++];\n    while (j < n2)\n        arr[k++] = R[j++];\n}\nvoid merge_sort(int arr[], int left, int right) {\n    if (left < right) {\n        int mid = left + (right - left) / 2;\n        merge_sort(arr, left, mid);\n        merge_sort(arr, mid + 1, right);\n        merge(arr, left, mid, right);\n    }\n}\n</code></pre>\n对长度为n的数组arr,调用函数merge_sort(a, 0, n-1),在排序过程中merge函数的递归调用次数大约是( )?",
        "options": ["A. O(n)", "B. O(n log n)", "C. O(log n)", "D. O(n²)"],
        "correct": "B",
        "explanation": "归并排序的merge调用次数与递归深度相关，每层merge的次数为n/2^k，总次数为O(n log n)，B正确。",
        "source": "GESP 2024年9月认证 C++ 五级真题.pdf 单选题第10题"
    },
    {
        "id": "13",
        "type": "single",
        "question": "关于分治算法,以下哪个说法正确?",
        "options": ["A. 分治算法将问题分成子问题,然后分别解决子问题,最后合并结果", "B. 归并排序不是分治算法的应用", "C. 分治算法通常用于解决小规模问题", "D. 分治算法的时间复杂度总是优于O(n log (n))"],
        "correct": "A",
        "explanation": "分治算法的核心是分解子问题并合并，归并排序是典型应用，A正确；B错误，C和D说法错误。",
        "source": "GESP 2024年9月认证 C++ 五级真题.pdf 单选题第12题"
    },
    {
        "id": "14",
        "type": "single",
        "question": "在快速排序中,选择的主元素(pivot)会影响算法的( )?",
        "options": ["A. 不影响", "B. 时间复杂度", "C. 空间复杂度", "D. 时间复杂度和空间复杂度"],
        "correct": "B",
        "explanation": "主元素的选择影响分区的平衡程度，从而影响时间复杂度，最好O(n log n)，最坏O(n²)，空间复杂度主要由递归深度决定，与主元素选择无关，B正确。",
        "source": "CCF GESP 2025年6月认证 C++ 5级试题.pdf 单选题第14题"
    },
    {
        "id": "15",
        "type": "single",
        "question": "归并排序的基本思想是( )?",
        "options": ["A. 将数组分成两个子数组,分别排序后再合并", "B. 随机选择一个元素作为枢轴,将数组划分为两个部分", "C. 从后往前逐步将每个元素插入到已排序数组中的合适位置", "D. 每次从待排序数组中选择最小的元素放到已排序数组末尾"],
        "correct": "A",
        "explanation": "归并排序的分治合并思想，A正确；B是快速排序，C是插入排序，D是选择排序。",
        "source": "CCF GESP 2025年6月认证 C++ 5级试题.pdf 单选题第16题"
    },
    {
        "id": "16",
        "type": "single",
        "question": "下面关于归并排序,描述正确的是( )?",
        "options": ["A. 归并排序是一个不稳定的排序算法", "B. 归并排序的时间复杂度在最优､最差和平均情况下都是O(n log n)", "C. 归并排序需要额外的O(1)空间", "D. 对于输入数组{12, 11, 13, 5, 6, 7},代码输出结果为:7 6 5 13 12 11"],
        "correct": "B",
        "explanation": "归并排序是稳定排序，时间复杂度稳定为O(n log n)，空间复杂度O(n)，B正确；A、C错误，D的输出应为升序排列。",
        "source": "GESP 2024年12月认证 C++ 5级真题.pdf 单选题第10题"
    },
    {
        "id": "17",
        "type": "single",
        "question": "为了正确实现快速排序,下面横线上的代码应为( )?\n<pre><code>void qsort(vector<int>& arr, int left, int right) {\n    int i, j, mid;\n    int pivot;\n    i = left;\n    j = right;\n    mid = (left + right) / 2;\n    pivot = arr[mid];\n    do {\n        while (arr[i] < pivot) i++;\n        while (arr[j] > pivot) j--;\n        if (i <= j) {\n            swap(arr[i], arr[j]);\n            i++;\n            j--;\n        }\n    } while (i <= j);\n    if (left < j)\n        qsort(arr, left, j);\n    if (i < right)\n        qsort(arr, i, right);\n    // 在此处填入代码\n}\n</code></pre>",
        "options": ["A. while (i <= mid)", "B. while (i < j)", "C. while (i < mid)", "D. while (i <= j)"],
        "correct": "B",
        "explanation": "快速排序的分区循环应在i < j时继续，直到i >= j时结束，B正确。",
        "source": "GESP 2024年12月认证 C++ 5级真题.pdf 单选题第9题"
    },
    {
        "id": "18",
        "type": "single",
        "question": "若用二分法在[1, 100]内猜数,最多需要猜( )次?",
        "options": ["A. 100", "B. 10", "C. 7", "D. 5"],
        "correct": "C",
        "explanation": "二分法的次数为log2(100)≈7，C正确。",
        "source": "CCF GESP 2025年3月认证 C++ 5级试题.pdf 单选题第11题"
    }
]