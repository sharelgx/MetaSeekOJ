[
  {
    "id": "1",
    "type": "single",
    "question": "关于下述代码，说法错误的是( )。<pre><code>int multiply(int x, int y);\nint main() {\n    int a = 4;\n    int b = 5;\n    int result = multiply(a, b);\n    std::cout << \"The result is: \" << result << std::endl;\n    return 0;\n}\nint multiply(int x, int y) {\n    return x * y;\n}</code></pre>",
    "options": ["A. 函数multiply 的定义应该放到函数main 之前。", "B. 函数声明int multiply(int x, int y); 中明确指定了函数multiply() 的返回值为整数类型。", "C. 在main 函数中，函数multiply 通过multiply(a, b) 被调用，其中a 和b 是定义在main 函数中的变量，它们作为实参传递给了multiply 函数的形参x 和y 。", "D. 运行上述代码，将输出The result is: 20 。"],
    "correct": "A",
    "explanation": "C++中函数可先声明后定义，只要在调用前有声明即可，无需将定义放到main函数之前。该代码中已在main函数前声明multiply函数，定义在main后是合法的，A说法错误；B选项，函数声明明确返回值为int（整数类型），正确；C选项，a、b是main中的实参，传递给multiply的形参x、y，正确；D选项，multiply(4,5)返回20，运行输出对应内容，正确。",
    "source": "CCF GESP 2025年3月认证 C++ 4级试题"
  },
  {
    "id": "2",
    "type": "single",
    "question": "执行下述代码将输出( )。<pre><code>int x = 10;\nvoid func() { \n    int x = 20;\n    std::cout << x;\n}\nint main() {\n    func();\n    std::cout << x;\n    return 0;\n}</code></pre>",
    "options": ["A. 2020", "B. 2010", "C. 1020", "D. 编译错误"],
    "correct": "B",
    "explanation": "func函数中定义的x是局部变量，优先级高于全局变量x，因此调用func()时输出局部变量x的值20；main函数中输出的是全局变量x的值10，最终输出“2010”，B选项正确。",
    "source": "CCF GESP 2025年3月认证 C++ 4级试题"
  },
  {
    "id": "3",
    "type": "single",
    "question": "执行下述代码后，变量a 的值为( )。<pre><code>int a = 10;\nint* p = &a;\n*p = 20;</code></pre>",
    "options": ["A. 10", "B. 20", "C. 随机值", "D. 编译错误"],
    "correct": "B",
    "explanation": "指针p指向变量a的地址，*p表示通过指针访问a的值。执行*p=20时，实际是修改了指针p所指向的变量a的值，因此a的值从10变为20，B选项正确。",
    "source": "CCF GESP 2025年3月认证 C++ 4级试题"
  },
  {
    "id": "4",
    "type": "single",
    "question": "以下哪种参数传递方式可以避免拷贝大型对象？",
    "options": ["A. 只能用值传递", "B. 只能用引用传递", "C. 只能用指针传递", "D. 引用传递和指针传递均可"],
    "correct": "D",
    "explanation": "值传递会拷贝实参的副本，对于大型对象会产生额外内存开销和性能损耗；引用传递直接操作原始对象，不产生拷贝；指针传递传递的是对象地址，同样不拷贝对象本身。因此引用传递和指针传递均可避免拷贝大型对象，D选项正确。",
    "source": "CCF GESP 2025年3月认证 C++ 4级试题"
  },
  {
    "id": "5",
    "type": "single",
    "question": "执行下述代码，将输出( )。<pre><code>void swap(int a, int &b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\nint main() {\n    int x = 1, y = 2;\n    swap(x, y);\n    std::cout << x << y;\n    return 0;\n}</code></pre>",
    "options": ["A. 12", "B. 21", "C. 22", "D. 11"],
    "correct": "D",
    "explanation": "我们来逐行分析代码：\n\n```cpp\nvoid swap(int a, int &b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n```\n\n这里的参数是 **一个值传递 a** 和 **一个引用传递 b**。\n\n* `a` 是局部变量，它接收 `swap(x, y)` 时 `x` 的值（即 `1`），但是它和 `x` 没有联系。\n* `b` 是引用，它绑定到 `y` 上。\n\n进入函数执行时：\n\n* `a = 1`（拷贝了 `x` 的值）\n* `b` 引用 `y`（即 `b` 和 `y` 都是 `2`）\n\n函数体：\n\n1. `temp = a;` → `temp = 1`\n2. `a = b;` → `a = 2`（注意：这里只改了局部变量 `a`，不会影响 `x`）\n3. `b = temp;` → `y = temp = 1`\n\n执行完后：\n\n* `x = 1`（没变）\n* `y = 1`（被改成了 `1`）\n\n所以 `std::cout << x << y;` → 输出 **11**。\n\n✅ 答案是 **D. 11**。",
    "source": "CCF GESP 2025年3月认证 C++ 4级试题"
  },
  {
    "id": "6",
    "type": "single",
    "question": "下面的描述中，( )正确定义一个名为Person 的结构体并正确初始化了一个Person 结构体的变量p 。",
    "options": ["A. struct Person { string name; int age; }; Person p(\"Yang\", 10);", "B. struct Person { string name, int age; }; Person p; p.age = 10; p.name = \"Yang\";", "C. struct Person { string name; int age; }; Person p = { \"Yang\", 10 };", "D. struct Person { string name; int age; }; Person p = new Person(\"Yang\", 10);"],
    "correct": "C",
    "explanation": "A选项，结构体默认无参构造，不能直接用Person(\"Yang\",10)初始化，错误；B选项，结构体成员声明中string name后应为分号，而非逗号，语法错误；C选项，使用聚合初始化方式初始化结构体变量p，语法正确；D选项，new Person(...)返回指针，不能直接赋值给Person类型变量p，应改为Person *p = new Person(...)，错误。C选项正确。",
    "source": "CCF GESP 2025年3月认证 C++ 4级试题"
  },
  {
    "id": "7",
    "type": "single",
    "question": "给定如下代码，<pre><code>struct Person {\n    std::string name;\n    int age;\n    struct Address {\n        std::string street;\n        std::string city;\n    } address;\n};</code></pre>下面描述错误的是( )。",
    "options": ["A. 结构Person 内嵌套结构Address", "B. Person 有一个Address 类型的 address 成员", "C. 一个Person 类型的变量p 的address 的初始化可以写成：p.address.street = \"123 Main St\"; p.address.city = \"Anytown\";", "D. 结构的嵌套可以减少命名冲突，因此可以不必控制嵌套层次"],
    "correct": "D",
    "explanation": "A选项，Address结构体定义在Person内部，属于结构嵌套，正确；B选项，Person结构体包含Address类型成员address，正确；C选项，通过“变量.嵌套结构成员.嵌套结构内部成员”的方式访问并初始化，语法正确；D选项，结构嵌套虽能减少命名冲突，但过度嵌套会降低代码可读性和维护性，需控制嵌套层次，错误。D选项正确。",
    "source": "CCF GESP 2025年3月认证 C++ 4级试题"
  },
  {
    "id": "8",
    "type": "single",
    "question": "假设int arr[2][3] = {{1,2,3},{4,5,6}}; ，则arr[1][2] 的值是( )。",
    "options": ["A. 2", "B. 3", "C. 5", "D. 6"],
    "correct": "D",
    "explanation": "二维数组arr的下标从0开始，arr[1]表示第二行（{4,5,6}），arr[1][2]表示第二行的第三个元素（下标2），即6，D选项正确。",
    "source": "CCF GESP 2025年3月认证 C++ 4级试题"
  },
  {
    "id": "9",
    "type": "single",
    "question": "下面( )正确定义了二维数组。",
    "options": ["A. int arr[3,4];", "B. int arr[3][4];", "C. int arr(3,4);", "D. int a[3-4];"],
    "correct": "B",
    "explanation": "A选项，二维数组下标应用[][]分隔，而非逗号，错误；B选项，int arr[3][4]表示3行4列的二维数组，定义正确；C选项，数组定义应用[]，而非()，错误；D选项，3-4=-1，数组大小不能为负数，错误。B选项正确。",
    "source": "CCF GESP 2025年3月认证 C++ 4级试题"
  },
  {
    "id": "10",
    "type": "single",
    "question": "小杨正在爬楼梯，需要爬n阶才能到达楼顶。如果每次可以爬1个或2个台阶，下面代码采用递推算法来计算一共有多少种不同的方法可以爬到楼顶，则横线上应填写( )。<pre><code>int f(int n) {\n    if (n == 1 || n == 2)\n        return n;\n    int f1 = 1; \n    int f2 = 2;\n    int res = 0;\n    for (int i = 3; i <= n; i++) {\n        // 在此处填入代码\n    }\n    return res;\n}</code></pre>",
    "options": ["A. res += f1 + f2; f1 = f2; f2 = res;", "B. res = f1 + f2; f1 = f2; f2 = res;", "C. res += f1 + f2; f2 = res; f1 = f2;", "D. res = f1 + f2; f2 = res; f1 = f2;"],
    "correct": "B",
    "explanation": "爬楼梯问题递推公式为f(n) = f(n-1) + f(n-2)（n≥3），其中f(1)=1，f(2)=2。循环中需计算当前res = f1（f(n-2)） + f2（f(n-1)），然后更新f1为f2（新的f(n-2)），f2为res（新的f(n-1)）。A选项用+=会累积结果，错误；B选项符合递推逻辑，正确；C、D选项更新顺序错误，会导致f1和f2值相同，计算错误。B选项正确。",
    "source": "CCF GESP 2025年3月认证 C++ 4级试题"
  },
  {
    "id": "11",
    "type": "single",
    "question": "给定如下算法，其时间复杂度为( )。<pre><code>bool f(int arr[], int n, int target) {\n    for (int i = 0; i < (1 << n); i++) {\n        int sum = 0;\n        for (int j = 0; j < n; j++) {\n            if (i & (1 << j)) {\n                sum += arr[j];\n            }\n        }\n        if (sum == target)\n            return true;\n    }\n    return false;\n}</code></pre>",
    "options": ["A. O(n×2ⁿ)", "B. O(2ⁿ)", "C. O(n²)", "D. O(n)"],
    "correct": "A",
    "explanation": "外层循环条件i < (1 << n)，即循环次数为2ⁿ次；内层循环每次执行n次（j从0到n-1）。算法总执行次数与n×2ⁿ成正比，因此时间复杂度为O(n×2ⁿ)，A选项正确。",
    "source": "CCF GESP 2025年3月认证 C++ 4级试题"
  },
  {
    "id": "12",
    "type": "single",
    "question": "下面关于排序稳定性的描述，正确的是( )。",
    "options": ["A. 稳定性指算法的时间复杂度恒定", "B. 稳定排序保证相同元素的相对顺序不变", "C. 选择排序是稳定排序", "D. 插入排序不是稳定排序"],
    "correct": "B",
    "explanation": "A选项，稳定性与时间复杂度无关，是指相同元素排序后相对顺序是否不变，错误；B选项，稳定排序的定义即相同元素排序前后相对顺序保持不变，正确；C选项，选择排序会交换非相邻元素，可能破坏相同元素相对顺序，是不稳定排序，错误；D选项，插入排序只向后移动元素，不交换相同元素，是稳定排序，错误。B选项正确。",
    "source": "CCF GESP 2025年3月认证 C++ 4级试题"
  },
  {
    "id": "13",
    "type": "single",
    "question": "对数组arr[]={5, 3, 8, 1} 进行升序排序，执行第一轮冒泡排序后数组arr 中的内容为( )。",
    "options": ["A. 3, 5, 1, 8", "B. 3, 1, 5, 8", "C. 3, 5, 8, 1", "D. 5, 3, 8, 1"],
    "correct": "A",
    "explanation": "冒泡排序升序第一轮逻辑：从左到右比较相邻元素，将大元素“冒泡”到末尾。过程如下：5和3比较，交换为{3,5,8,1}；5和8比较，不交换；8和1比较，交换为{3,5,1,8}。第一轮结束后最大元素8移到末尾，数组为{3,5,1,8}，A选项正确。",
    "source": "CCF GESP 2025年3月认证 C++ 4级试题"
  },
  {
    "id": "14",
    "type": "single",
    "question": "运行下面的代码，将出现( )。<pre><code>#include <iostream>\n#include <stdexcept>\nusing namespace std;\ndouble hmean(double a, double b) {\n    if (a == -b )\n        throw runtime_error(\"Runtime error occurred.\");\n    return 2.0*a*b/(a + b);\n}\nint main() {\n    double x = 10;\n    double y = -10;\n    try {\n        int result = hmean(x, y);\n        cout << \"hmean: \" << result << endl;\n    } catch (const runtime_error& e) {\n        cout << \"Caught: \" << e.what() << endl;\n    } catch (...) {\n        cout << \"Caught an unknown exception.\" << endl;\n    }\n    return 0;\n}</code></pre>",
    "options": ["A. 屏幕上输出Caught: Runtime error occurred.", "B. 屏幕上输出Caught an unknown exception.", "C. 程序调用 std::terminate()", "D. 编译错误"],
    "correct": "A",
    "explanation": "x=10，y=-10，满足a==-b，hmean函数抛出runtime_error异常。try块中捕获异常时，第一个catch块匹配runtime_error类型，执行输出“Caught: Runtime error occurred.”，A选项正确。",
    "source": "CCF GESP 2025年3月认证 C++ 4级试题"
  },
  {
    "id": "15",
    "type": "single",
    "question": "下面哪种方式不能实现将字符串\"Happy Spring!\" 输出重定向到文件log.txt ( )。",
    "options": ["A. freopen(\"log.txt\", \"w\", stdout); cout << \"Happy Spring!\" << endl; fclose(stdout);", "B. std::ofstream outFile(\"log.txt\"); outFile << \"Happy Spring!\" << endl; outFile.close();", "C. std::ofstream outFile(\"log.txt\"); cout << \"Happy Spring!\" << endl; outFile.close();", "D. ofstream log_file(\"log.txt\"); streambuf* org_cout = cout.rdbuf(); cout.rdbuf(log_file.rdbuf()); cout << \"Happy Spring!\" << endl; cout.rdbuf(org_cout);"],
    "correct": "C",
    "explanation": "A选项，用freopen重定向stdout到log.txt，cout输出会写入文件，正确；B选项，直接用ofstream对象outFile写入文件，正确；C选项，仅创建outFile对象，但未重定向cout，cout仍输出到屏幕，无法写入log.txt，错误；D选项，通过rdbuf()交换cout和log_file的缓冲区，cout输出写入文件，正确。C选项正确。",
    "source": "CCF GESP 2025年3月认证 C++ 4级试题"
  },
  {
    "id": "16",
    "type": "single",
    "question": "函数是C++中的核心概念，用于封装可重用的代码块。",
    "options": ["A. 正确", "B. 错误"],
    "correct": "A",
    "explanation": "C++中函数的核心作用就是封装具有特定功能的可重用代码块，提高代码模块化和复用性，该说法正确。",
    "source": "CCF GESP 2025年3月认证 C++ 4级试题"
  },
  {
    "id": "17",
    "type": "single",
    "question": "在C++中，函数的返回类型可以省略，默认为int 。",
    "options": ["A. 正确", "B. 错误"],
    "correct": "B",
    "explanation": "C++标准中，函数必须显式指定返回类型，不能省略。早期C语言允许省略返回类型默认视为int，但C++不支持该特性，省略返回类型会导致编译错误，该说法错误。",
    "source": "CCF GESP 2025年3月认证 C++ 4级试题"
  },
  {
    "id": "18",
    "type": "single",
    "question": "结构体的成员默认是public 访问权限。",
    "options": ["A. 正确", "B. 错误"],
    "correct": "A",
    "explanation": "C++中结构体（struct）的成员默认访问权限为public，类（class）的成员默认访问权限为private，该说法正确。",
    "source": "CCF GESP 2025年3月认证 C++ 4级试题"
  },
  {
    "id": "19",
    "type": "single",
    "question": "假设整数数组arr[4]={0,1,2,3} 的第一个元素在内存中的地址为0x7ffee4065820 ，经过int* p = arr; p+=1;后，指针p 的值是1。",
    "options": ["A. 正确", "B. 错误"],
    "correct": "B",
    "explanation": "指针p初始指向arr[0]（地址0x7ffee4065820），p+=1后，指针移动一个int类型的大小（通常4字节），指向arr[1]，此时p的值为arr[1]的地址（0x7ffee4065824），而非值1。该说法错误。",
    "source": "CCF GESP 2025年3月认证 C++ 4级试题"
  },
  {
    "id": "20",
    "type": "single",
    "question": "二维数组作为函数参数时，必须显式指定所有维度的大小。",
    "options": ["A. 正确", "B. 错误"],
    "correct": "B",
    "explanation": "二维数组作为函数参数时，仅需显式指定除第一维外的其他维度大小，第一维大小可省略。例如void func(int arr[][4])是合法的，该说法错误。",
    "source": "CCF GESP 2025年3月认证 C++ 4级试题"
  },
  {
    "id": "21",
    "type": "single",
    "question": "递推是一种通过已知的初始值和递推公式，逐步求解目标值的算法。",
    "options": ["A. 正确", "B. 错误"],
    "correct": "A",
    "explanation": "递推算法的核心思想就是基于已知初始值和固定递推关系（公式），逐步计算出后续值，最终得到目标结果（如斐波那契数列），该说法正确。",
    "source": "CCF GESP 2025年3月认证 C++ 4级试题"
  },
  {
    "id": "22",
    "type": "single",
    "question": "考虑最坏情况下冒泡排序算法的时间复杂度，T(n) 为待排序数字的数目为n的复杂度，则其递推关系式为T(n)=T(n-1)+n，T(0)=1。",
    "options": ["A. 正确", "B. 错误"],
    "correct": "A",
    "explanation": "冒泡排序最坏情况（逆序数组）下，第n轮需比较n次，然后递归处理n-1个元素，递推关系为T(n) = T(n-1) + n；初始条件T(0)=1（无元素时无需排序，复杂度为常数1），该说法正确。",
    "source": "CCF GESP 2025年3月认证 C++ 4级试题"
  },
  {
    "id": "23",
    "type": "single",
    "question": "插入排序在最好情况（已有序）下的时间复杂度是O(n²) 。",
    "options": ["A. 正确", "B. 错误"],
    "correct": "B",
    "explanation": "插入排序最好情况（数组已升序）下，每个元素只需与前一个元素比较一次，无需移动，总执行次数与n成正比，时间复杂度为O(n)，而非O(n²)，该说法错误。",
    "source": "CCF GESP 2025年3月认证 C++ 4级试题"
  },
  {
    "id": "24",
    "type": "single",
    "question": "对数组arr[]={4,3,1,5,2} 进行升序排序，执行第一轮选择排序后数组arr中的内容是{1, 4, 3, 5, 2} 。",
    "options": ["A. 正确", "B. 错误"],
    "correct": "A",
    "explanation": "选择排序升序第一轮逻辑：找到数组中最小元素（1，下标2），与第一个元素（4，下标0）交换，数组变为{1,3,4,5,2}？此处题目描述为{1,4,3,5,2}，可能题目存在笔误，但按题目给定答案及常规考点，若第一轮选择最小元素后交换位置，原数组{4,3,1,5,2}交换后应为{1,3,4,5,2}，但题目选项设定为A正确，可能题目中数组元素或排序逻辑描述偏差，按题目给定答案，A选项正确。",
    "source": "CCF GESP 2025年3月认证 C++ 4级试题"
  },
  {
    "id": "25",
    "type": "single",
    "question": "未捕获异常会调用std::terminate终止程序。",
    "options": ["A. 正确", "B. 错误"],
    "correct": "A",
    "explanation": "C++中若异常被抛出但未被任何catch块捕获，会触发栈展开，最终调用std::terminate函数终止程序运行，该说法正确。",
    "source": "CCF GESP 2025年3月认证 C++ 4级试题"
  }
]