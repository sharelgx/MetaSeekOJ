[
  {
    "id": "1",
    "type": "single",
    "question": "运行下面代码片段后，x和*p的结果分别是( )。<pre><code>int x = 20;\nint* p = &x;\n*p = *p + 2;</code></pre>",
    "options": ["A. 20 20", "B. 20 22", "C. 22 20", "D. 22 22"],
    "correct": "D",
    "explanation": "p指向x，*p = *p + 2即x = 20 + 2 = 22，因此x和*p的值均为22，选项D正确。",
    "source": "2024年12月认证C++四级真题.pdf"
  },
  {
    "id": "2",
    "type": "single",
    "question": "下面的描述中，( )正确定义一个名为Person的结构体并正确初始化了一个Person结构体的变量p。",
    "options": [
      "A. <pre><code>struct Person {\n    string name;\n    int age;\n};\nPerson p(\"Yang\", 10);</code></pre>",
      "B. <pre><code>struct Person {\n    string name,\n    int age;\n};\nPerson p;\n p.age = 10;\n p.name = \"Yang\";</code></pre>",
      "C. <pre><code>struct Person {\n    string name;\n    int age;\n};\nPerson p = { \"Yang\", 10 };</code></pre>",
      "D. <pre><code>struct Person {\n    string name;\n    int age;\n};\nPerson p = new Person(\"Yang\", 10);</code></pre>"
    ],
    "correct": "C",
    "explanation": "选项C正确使用聚合初始化初始化结构体变量p。选项A使用构造函数初始化，结构体默认无此构造函数；选项B中name后应为分号；选项D中p是结构体变量，不能用new赋值，均错误。",
    "source": "2025年3月认证C++四级真题.pdf"
  },
  {
    "id": "3",
    "type": "single",
    "question": "冒泡排序的平均时间复杂度为O(n²)，但最优情况下为O(n)。",
    "options": ["A. 正确", "B. 错误"],
    "correct": "A",
    "explanation": "冒泡排序平均时间复杂度为O(n²)，最优情况（数组已排序）下通过标志位可优化为O(n)，说法正确。",
    "source": "2024年12月认证C++四级真题.pdf"
  },
  {
    "id": "4",
    "type": "single",
    "question": "选择排序是稳定的排序算法。",
    "options": ["A. 正确", "B. 错误"],
    "correct": "B",
    "explanation": "选择排序在交换元素时可能改变相同元素的相对顺序，是不稳定的排序算法，说法错误。",
    "source": "2024年12月认证C++四级真题.pdf"
  },
  {
    "id": "5",
    "type": "single",
    "question": "在C++语言中，如果一个函数可能抛出异常，那么一定要在try子句里调用这个函数。",
    "options": ["A. 正确", "B. 错误"],
    "correct": "B",
    "explanation": "可能抛出异常的函数可以不在try子句中调用，异常会向上传播由上层处理，说法错误。",
    "source": "2024年12月认证C++四级真题.pdf"
  },
  {
    "id": "6",
    "type": "single",
    "question": "运行下面代码片段的结果是( )。<pre><code>int y = 24;\nint x = 20;\nint* p = &x;\nint* q = &y;\np = q;</code></pre>",
    "options": ["A. x将赋值为24", "B. y将赋值为20", "C. p将指向y的地址", "D. q将指向x的地址"],
    "correct": "C",
    "explanation": "p初始指向x，q指向y，p = q后，p指向y的地址，选项C正确。x和y的值未改变，q的指向也未改变，A、B、D错误。",
    "source": "2024年9月认证C++四级试题.pdf"
  },
  {
    "id": "7",
    "type": "single",
    "question": "在C++中，( )正确定义一个名为student的结构体，其中包含一个name字符数组和一个age整数？",
    "options": ["A. struct student { char name[20]; int age; };", "B. student struct { char name[20]; int age; };", "C. student struct { string name; int age; };", "D. struct student { char[20] name; int age; };"],
    "correct": "A",
    "explanation": "选项A正确定义了结构体student，包含字符数组name和整数age。选项B、C结构体定义语法顺序错误；选项D数组定义语法错误（应为char name[20]）。",
    "source": "2024年9月认证C++四级试题.pdf"
  },
  {
    "id": "8",
    "type": "single",
    "question": "在C++中，( )正确声明了一个3行4列的二维数组。",
    "options": ["A. int arr[3, 4];", "B. int arr[3][4];", "C. int arr[4][3];", "D. int arr(3, 4);"],
    "correct": "B",
    "explanation": "选项B正确声明了一个3行4列的二维数组。选项A和D的语法错误，选项C声明的是4行3列的二维数组。",
    "source": "2024年9月认证C++四级试题.pdf"
  },
  {
    "id": "9",
    "type": "single",
    "question": "给定如下算法，其时间复杂度为( )。<pre><code>bool f(int arr[], int n, int target) {\n    for (int i = 0; i < (1 << n); i++) {\n        int sum = 0;\n        for (int j = 0; j < n; j++) {\n            if (i & (1 << j)) {\n                sum += arr[j];\n            }\n        }\n        if (sum == target)\n            return true;\n    }\n    return false;\n}</code></pre>",
    "options": ["A. O(n²)", "B. O(n×2ⁿ)", "C. O(2ⁿ)", "D. O(n×log n)"],
    "correct": "B",
    "explanation": "外层循环执行2ⁿ次，内层循环执行n次，时间复杂度为O(n×2ⁿ)，选项B正确。",
    "source": "2025年3月认证C++四级真题.pdf"
  },
  {
    "id": "10",
    "type": "single",
    "question": "下面关于排序稳定性的描述，正确的是( )。",
    "options": ["A. 稳定性指算法的时间复杂度恒定", "B. 稳定排序保证相同元素的相对顺序不变", "C. 选择排序是稳定排序", "D. 插入排序不是稳定排序"],
    "correct": "B",
    "explanation": "稳定排序的定义是排序后相同元素的相对顺序与排序前保持一致，选项B正确。选项A错误，稳定性与时间复杂度无关；选择排序不稳定，选项C错误；插入排序稳定，选项D错误。",
    "source": "2025年3月认证C++四级真题.pdf"
  },
  {
    "id": "11",
    "type": "single",
    "question": "给定如下代码，下面描述错误的是( )。<pre><code>struct Person {\n    std::string name;\n    int age;\n    struct Address {\n        std::string street;\n        std::string city;\n    };\n    Address address;\n};</code></pre>",
    "options": ["A. 结构Person内嵌套结构Address", "B. Person有一个Address类型的address成员", "C. 一个Person类型的变量p的address的初始化可以写成：p.address.street = \"123 Main St\"; p.address.city = \"Anytown\";", "D. 结构的嵌套可以减少命名冲突，因此可以不必控制嵌套层次"],
    "correct": "D",
    "explanation": "结构嵌套虽可减少命名冲突，但过度嵌套会降低代码可读性，需要控制嵌套层次，选项D说法错误。其他选项描述正确。",
    "source": "2025年3月认证C++四级真题.pdf"
  },
  {
    "id": "12",
    "type": "single",
    "question": "假设int arr[2][3] = {{1,2,3},{4,5,6}};，则arr[1][2]的值是( )。",
    "options": ["A. 2", "B. 3", "C. 5", "D. 6"],
    "correct": "D",
    "explanation": "arr[1]表示第二行，arr[1][2]是第二行第三列元素，值为6，选项D正确。",
    "source": "2025年3月认证C++四级真题.pdf"
  },
  {
    "id": "13",
    "type": "single",
    "question": "下面( )正确定义了二维数组。",
    "options": ["A. int arr[3,4];", "B. int arr[3][4];", "C. int arr(3,4);", "D. int a[3-4];"],
    "correct": "B",
    "explanation": "选项B正确定义了二维数组。选项A和C的语法错误，选项D的表达式错误。",
    "source": "2025年3月认证C++四级真题.pdf"
  },
  {
    "id": "14",
    "type": "single",
    "question": "递推算法通常有初始值。",
    "options": ["A. 正确", "B. 错误"],
    "correct": "A",
    "explanation": "递推算法通过初始值和递推关系逐步求解问题，初始值是计算的基础。",
    "source": "GESP C++四级样题卷.pdf"
  },
  {
    "id": "15",
    "type": "single",
    "question": "冒泡排序是一种稳定的排序算法。",
    "options": ["A. 正确", "B. 错误"],
    "correct": "A",
    "explanation": "冒泡排序中，相等元素不会交换位置，因此是稳定的排序算法。",
    "source": "GESP C++四级样题卷.pdf"
  },
  {
    "id": "16",
    "type": "single",
    "question": "C++语言中，如果异常发生，但没有处理异常的代码，则程序会由于一直等待处理而死机。",
    "options": ["A. 正确", "B. 错误"],
    "correct": "B",
    "explanation": "未处理的异常会导致程序终止，而非一直等待。",
    "source": "GESP C++四级样题卷.pdf"
  },
  {
    "id": "17",
    "type": "single",
    "question": "C++语言中的局部变量在函数调用结束后会被销毁。",
    "options": ["A. 正确", "B. 错误"],
    "correct": "A",
    "explanation": "局部变量的作用域在函数内部，函数调用结束后会被自动销毁。",
    "source": "GESP C++四级样题卷.pdf"
  },
  {
    "id": "18",
    "type": "single",
    "question": "在C++中，引用传递允许函数修改传递给它的参数的值。",
    "options": ["A. 正确", "B. 错误"],
    "correct": "A",
    "explanation": "引用传递中，函数接收的是实参的别名，修改引用会直接改变实参的值，说法正确。",
    "source": "2024年9月认证C++四级试题.pdf"
  },
  {
    "id": "19",
    "type": "single",
    "question": "指针的大小与其所指向的变量的数据类型的大小相同。",
    "options": ["A. 正确", "B. 错误"],
    "correct": "B",
    "explanation": "指针的大小取决于系统架构（如32位系统4字节，64位系统8字节），与所指向变量的类型无关，说法错误。",
    "source": "2024年9月认证C++四级试题.pdf"
  },
  {
    "id": "20",
    "type": "single",
    "question": "二维数组的行的大小必须在定义时确定，列的大小可以动态变化。",
    "options": ["A. 正确", "B. 错误"],
    "correct": "B",
    "explanation": "二维数组的行和列大小在定义时都必须确定，不能动态变化（动态数组需用指针实现），说法错误。",
    "source": "2024年9月认证C++四级试题.pdf"
  },
  {
    "id": "21",
    "type": "single",
    "question": "递推算法通过逐步求解当前状态和前一个或几个状态之间的关系来解决问题。",
    "options": ["A. 正确", "B. 错误"],
    "correct": "A",
    "explanation": "递推算法的核心是利用当前状态与前序状态的关系逐步求解，说法正确。",
    "source": "2024年9月认证C++四级试题.pdf"
  },
  {
    "id": "22",
    "type": "single",
    "question": "插入排序的时间复杂度总是比冒泡排序低。",
    "options": ["A. 正确", "B. 错误"],
    "correct": "B",
    "explanation": "插入排序和冒泡排序的平均及最坏时间复杂度均为O(n²)，不存在插入排序总是更低的情况，说法错误。",
    "source": "2024年9月认证C++四级试题.pdf"
  },
  {
    "id": "23",
    "type": "single",
    "question": "在C++中，如果没有捕获到异常（没有匹配的catch块），程序会继续执行而不会终止。",
    "options": ["A. 正确", "B. 错误"],
    "correct": "B",
    "explanation": "未捕获的异常会导致程序异常终止，不会继续执行，说法错误。",
    "source": "2024年9月认证C++四级试题.pdf"
  },
  {
    "id": "24",
    "type": "single",
    "question": "函数不可以调用自己。",
    "options": ["A. 正确", "B. 错误"],
    "correct": "B",
    "explanation": "函数可以调用自己，这称为递归函数，所以该说法错误。",
    "source": "2024年6月GESP C++四级真题.pdf"
  },
  {
    "id": "25",
    "type": "single",
    "question": "函数参数传递过程中，如果传常量值、常量引用和常量指针都是不能被修改的，它们可以防止函数对实参的值或地址进行修改。",
    "options": ["A. 正确", "B. 错误"],
    "correct": "A",
    "explanation": "传常量值时，函数内部不能修改该值；常量引用和常量指针也限制了函数内部对所指向对象的修改，所以它们可以防止函数对实参的值或地址进行修改，该说法正确。",
    "source": "2024年6月GESP C++四级真题.pdf"
  }
]