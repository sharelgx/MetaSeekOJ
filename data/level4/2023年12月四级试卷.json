[
  {
    "id": "1",
    "type": "single",
    "question": "下面有关函数参数的说法，正确的是( )。",
    "options": ["A. 函数参数传递时，主函数当中采用值传递方式将参数传递给子函数时，若子函数将参数值改变，主函数当中的参数值不变。", "B. 函数参数传递时，主函数当中采用值传递方式将参数传递给子函数时，若子函数将参数值改变，主函数当中的参数值将随子函数一样改变而改变。", "C. 函数参数传递时，主函数如果将参数的地址传递给子函数，若子函数将参数值改变，主函数当中的参数值将不改变。", "D. 函数参数传递可以不满足子函数的参数个数要求。"],
    "correct": "A",
    "explanation": "值传递中，子函数修改的是参数副本，不影响主函数原参数；地址传递时，子函数通过指针修改会影响主函数参数；函数调用必须满足参数个数要求。",
    "source": "2023年12月GESP C++四级真题"
  },
  {
    "id": "2",
    "type": "single",
    "question": "下面C++代码执行后，输出的是( )。<pre><code>int arr[10] = {1}; string strArr = \"chen a dai\"; cout << strArr[arr[1]] << endl;</code></pre>",
    "options": ["A. chen", "B. c", "C. chen a dai", "D. dai"],
    "correct": "B",
    "explanation": "数组arr初始化时，arr[0]为1，其余元素为0，故arr[1] = 0。strArr[0]为字符'c'。",
    "source": "2023年12月GESP C++四级真题"
  },
  {
    "id": "3",
    "type": "single",
    "question": "下面C++代码最后执行后输出是( )。<pre><code>int fun1(int* n) { return *n * *n; } int main() { int arr[10] = {2}; arr[1] = fun1(arr); cout << arr[1] << endl; }</code></pre>",
    "options": ["A. 1", "B. 2", "C. 3", "D. 4"],
    "correct": "D",
    "explanation": "arr初始化后arr[0] = 2，fun1接收arr首地址，计算*n（即arr[0]）的平方为4，故arr[1] = 4。",
    "source": "2023年12月GESP C++四级真题"
  },
  {
    "id": "4",
    "type": "single",
    "question": "下面C++代码执行后的结果是( )。<pre><code>int arr[3][3] = {{1,2,3}, {4,5,6}, {7,8,9}}; for(int i=0; i<3; i++) { for(int j=2; j>=0; j--) { cout << arr[i][j] << \"\"; } cout << endl; }</code></pre>",
    "options": ["A. 321 654 987", "B. 123 456 789", "C. 987 654 321", "D. 123 654 987"],
    "correct": "A",
    "explanation": "内层循环从j=2到j=0遍历，依次输出每行元素的逆序：第0行321，第1行654，第2行987。",
    "source": "2023年12月GESP C++四级真题"
  },
  {
    "id": "5",
    "type": "single",
    "question": "下面C++代码执行后输出是( )。<pre><code>int arr[3] = {1,2,3}; int *p = NULL; p = arr; p++; cout << *p << endl;</code></pre>",
    "options": ["A. 1,2,3", "B. 1", "C. 2", "D. 3"],
    "correct": "C",
    "explanation": "p指向arr首地址（arr[0]），p++后指向arr[1]，*p为2。",
    "source": "2023年12月GESP C++四级真题"
  },
  {
    "id": "6",
    "type": "single",
    "question": "如果变量x的地址是0x6ffe14，下面C++代码执行以后输出的是( )。<pre><code>int *p = NULL; int x = 2; p = &x; p++; cout << p << endl;</code></pre>",
    "options": ["A. 0x6ffe11", "B. 0x6ffe14", "C. 0x6ffe18", "D. 0x6ffe15"],
    "correct": "C",
    "explanation": "int类型占4字节，p指向x的地址0x6ffe14，p++后地址增加4，为0x6ffe18。",
    "source": "2023年12月GESP C++四级真题"
  },
  {
    "id": "7",
    "type": "single",
    "question": "在C++中，执行下面代码后，输出的是( )。<pre><code>int point(int* p) { return *p * *p; } int main() { int a = 20; int* p = &a; *p = point(p); cout << *p << endl; }</code></pre>",
    "options": ["A. 400", "B. 200", "C. 20", "D. 100"],
    "correct": "A",
    "explanation": "point函数计算*p（初始为20）的平方400，*p被赋值为400，故输出400。",
    "source": "2023年12月GESP C++四级真题"
  },
  {
    "id": "8",
    "type": "single",
    "question": "下列C++语句执行以后结果是true的是( )。",
    "options": ["A. 3 && false", "B. 5 && 2", "C. 101 && 000", "D. 4 & true"],
    "correct": "B",
    "explanation": "逻辑与（&&）中，非0值视为true。5和2均为非0，故5 && 2为true。",
    "source": "2023年12月GESP C++四级真题"
  },
  {
    "id": "9",
    "type": "single",
    "question": "在如下的C++代码中实现了对字符串中出现的26个字母的个数统计，横线处应填入是( )。<pre><code>char alpha[26] = {65}; string str = \"HELLO CHEN A DAI\"; int strlen = str.length(); int cnt[26] = {0}; for(int i=1; i<26; i++) { // 横线处 } for(int i=0; i<26; i++) cout << alpha[i] << \"\"; cout << endl; for(int i=0; i<26; i++) for(int j=0; j<strlen; j++) { if(alpha[i] == str[j]) cnt[i]++; } for(int i=0; i<26; i++) cout << cnt[i] << \"\"; </code></pre>",
    "options": ["A. alpha[i] = alpha[i-1] + 1;", "B. alpha[i] = alpha[i] + 1;", "C. alpha[i+1] = alpha[i] + 1;", "D. alpha[i-1] = alpha[i] + 1;"],
    "correct": "A",
    "explanation": "alpha[0]初始为65（'A'），循环需依次赋值后续字母（'B'到'Z'），故alpha[i] = alpha[i-1] + 1。",
    "source": "2023年12月GESP C++四级真题"
  },
  {
    "id": "10",
    "type": "single",
    "question": "下面C++代码执行后生成的文件其字节数为( )。<pre><code>ofstream fout; fout.open(\"1.txt\"); for(int i=1; i<=10; i++) { if(i%5 == 0) { int x = 6; fout << x; } else { char ch = 'A'; fout << ch; } }</code></pre>",
    "options": ["A. 10", "B. 16", "C. 40", "D. 24"],
    "correct": "A",
    "explanation": "循环10次，i=5和10时写入字符'6'（1字节），其余8次写入'A'（1字节），共10字节。",
    "source": "2023年12月GESP C++四级真题"
  },
  {
    "id": "11",
    "type": "single",
    "question": "下列C++代码输入1,2,3,4，执行后，将输出的是( )。<pre><code>string str; cin >> str; int strlen = str.length(); for(int i=0; i<strlen; i++) { if(str[i] <= '9' && str[i] >= '0') cout << str[i]; else cout << \"#\"; }</code></pre>",
    "options": ["A. 1#2#3#4", "B. 1#3#", "C. 1#2#3#4#", "D. 1#2#3#4"],
    "correct": "A",
    "explanation": "输入字符串为\"1,2,3,4\"，数字'1','2','3','4'分别输出，逗号输出'#'，结果为1#2#3#4。",
    "source": "2023年12月GESP C++四级真题"
  },
  {
    "id": "12",
    "type": "single",
    "question": "以下C++代码用于实现每个整数对应的因数，如输入12，则输出1 2 3 4 6 12；如输入18，则输出1 2 3 6 9 18。横线处应填入代码是( )。<pre><code>int n; cin >> n; for(int i=1; i<=n; i++) { // 横线处 cout << i << \"\"; }</code></pre>",
    "options": ["A. if(n%i == 0)", "B. if(n/i == 0)", "C. if(n%i != 0)", "D. if(n/i != 0)"],
    "correct": "A",
    "explanation": "因数是能整除n的数，故判断条件为n%i == 0。",
    "source": "2023年12月GESP C++四级真题"
  },
  {
    "id": "13",
    "type": "single",
    "question": "某公司新出了一款无人驾驶的小汽车，通过声控智能驾驶系统，乘客只要告诉汽车目的地，车子就能自动选择一条优化路线，告诉乘客后驶达那里。请问下面哪项不是驾驶系统完成选路所必须的。( )",
    "options": ["A. 麦克风", "B. 扬声器", "C. 油量表", "D. 传感器"],
    "correct": "C",
    "explanation": "麦克风用于接收声控指令，扬声器用于告知路线，传感器用于感知环境；油量表与选路无关。",
    "source": "2023年12月GESP C++四级真题"
  },
  {
    "id": "14",
    "type": "single",
    "question": "现代计算机是指电子计算机，它所基于的是( )体系结构。",
    "options": ["A. 艾伦·图灵", "B. 冯·诺依曼", "C. 阿塔纳索夫", "D. 埃克特-莫克利"],
    "correct": "B",
    "explanation": "现代电子计算机基于冯·诺依曼体系结构，其特点包括存储程序等。",
    "source": "2023年12月GESP C++四级真题"
  },
  {
    "id": "15",
    "type": "single",
    "question": "输入一个正整数N(N>=7)，想找出它所有相邻的因数对，比如，输入12，因数对有(1,2)、(2,3)、(3,4)。下面哪段代码找不到所有的因数对?( )",
    "options": ["A. for(i=1;i&lt;N;i++) if(!(N%i) && !(N%(i+1))) printf(\"(%d,%d)\\n\", i, i+1);", "B. for(i=2;i&lt;N;i++) if(!(N%i) && !(N%(i+1))) printf(\"(%d,%d)\\n\", i, i+1);", "C. for(i=2;i&lt;N/2;i++) if(!(N%(i-1)) && !(N%i)) printf(\"(%d,%d)\\n\", i-1, i);", "D. for(i=1;i&lt;N/2;i++) if(!(N%i) && !(N%(i+1))) printf(\"(%d,%d)\\n\", i, i+1);"],
    "correct": "B",
    "explanation": "选项B的循环从i=2开始，会遗漏i=1的情况（如(1,2)），故无法找到所有因数对。",
    "source": "2023年12月GESP C++四级真题"
  },
  {
    "id": "16",
    "type": "single",
    "question": "C++的内置函数sort()支持数组的局部排序。例如a={10,9,8,7,6,5,4,3,2,1}，可以用sort(a,a+5)，排序成{6,7,8,9,10,5,4,3,2,1}。( )",
    "options": ["A. 正确", "B. 错误"],
    "correct": "A",
    "explanation": "sort函数可通过指定起始和结束迭代器（如a和a+5）实现局部排序，将前5个元素升序排列。",
    "source": "2023年12月GESP C++四级真题"
  },
  {
    "id": "17",
    "type": "single",
    "question": "用递归法求n的阶乘，时间复杂度是O(n)。( )",
    "options": ["A. 正确", "B. 错误"],
    "correct": "A",
    "explanation": "递归求阶乘需调用n次递归函数，每次操作时间为O(1)，总时间复杂度为O(n)。",
    "source": "2023年12月GESP C++四级真题"
  },
  {
    "id": "18",
    "type": "single",
    "question": "[(1,2)*2]*3在C++中是合法的表达式。( )",
    "options": ["A. 正确", "B. 错误"],
    "correct": "B",
    "explanation": "C++中没有逗号表达式直接用于乘法的语法，(1,2)为逗号表达式值为2，但整体表达式语法不合法。",
    "source": "2023年12月GESP C++四级真题"
  },
  {
    "id": "19",
    "type": "single",
    "question": "在下面的C++代码中，将对1.txt文件写入hello。( )<pre><code>ifstream filein; ofstream fileout; filein.open(\"1.txt\"); fileout << \"hello\";</code></pre>",
    "options": ["A. 正确", "B. 错误"],
    "correct": "B",
    "explanation": "fileout未调用open打开文件，无法写入内容到1.txt。",
    "source": "2023年12月GESP C++四级真题"
  },
  {
    "id": "20",
    "type": "single",
    "question": "文本文件1.txt第1行由01234共5个字符组成其间没有空格，当用C++代码正常打开文件成功并执行如下代码以后，第1行长度为5( )<pre><code>ifstream filein; int buff; filein.open(\"1.txt\"); filein >> buff; cout << buff << endl;</code></pre>",
    "options": ["A. 正确", "B. 错误"],
    "correct": "B",
    "explanation": "代码中filein >> buff读取整数01234（值为1234），但未修改文件内容，文件第1行长度仍为5。不过题目可能考察读取后对文件的影响，实际文件本身不变，但此处解析可能存在歧义，根据题意判断为错误。",
    "source": "2023年12月GESP C++四级真题"
  },
  {
    "id": "21",
    "type": "single",
    "question": "执行C++代码cout << (5 || 2);后将输出1。( )",
    "options": ["A. 正确", "B. 错误"],
    "correct": "A",
    "explanation": "逻辑或（||）中，5和2均为非0，结果为true，输出为1。",
    "source": "2023年12月GESP C++四级真题"
  },
  {
    "id": "22",
    "type": "single",
    "question": "在C++中，两个字符串相加的运算符为+相当于字符串的合并运算。下面C++代码执行后，将输出chenadai。( )<pre><code>string a = \"chen\"; string b = \"a\"; string c = \"dai\"; string name = a + b + c; cout << name << endl;</code></pre>",
    "options": ["A. 正确", "B. 错误"],
    "correct": "A",
    "explanation": "string类支持+运算符进行字符串拼接，a+b+c结果为\"chenadai\"。",
    "source": "2023年12月GESP C++四级真题"
  },
  {
    "id": "23",
    "type": "single",
    "question": "C++内置函数sort()可以对整数、浮点数、字符数组进行从大到小，从小到大，局部排序。( )",
    "options": ["A. 正确", "B. 错误"],
    "correct": "A",
    "explanation": "sort函数可通过自定义比较器实现从大到小排序，默认从小到大，也可指定范围进行局部排序，支持多种数据类型。",
    "source": "2023年12月GESP C++四级真题"
  },
  {
    "id": "24",
    "type": "single",
    "question": "小杨最近在准备考GESP，他用的Dev C++来练习和运行程序，所以Dev C++也是一个小型操作系统。( )",
    "options": ["A. 正确", "B. 错误"],
    "correct": "B",
    "explanation": "Dev C++是集成开发环境（IDE），用于编写和运行程序，并非操作系统。",
    "source": "2023年12月GESP C++四级真题"
  },
  {
    "id": "25",
    "type": "single",
    "question": "任何一个while循环都可以转化为等价的for循环( )。",
    "options": ["A. 正确", "B. 错误"],
    "correct": "A",
    "explanation": "for循环的语法结构（初始化、条件、迭代）可覆盖while循环的逻辑，任何while循环都能改写为for循环。",
    "source": "2023年12月GESP C++四级真题"
  }
]