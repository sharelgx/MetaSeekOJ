# MetaSeekOJ é€‰æ‹©é¢˜åˆ¤é¢˜åŠŸèƒ½å¼€å‘æ–‡æ¡£

## ğŸ“‹ é¡¹ç›®æ¦‚è¿°

æœ¬æ–‡æ¡£åŸºäº MetaSeekOJ ç³»ç»Ÿç°æœ‰æ¶æ„ï¼Œè¯¦ç»†è¯´æ˜é€‰æ‹©é¢˜åˆ¤é¢˜åŠŸèƒ½çš„å¼€å‘è§„èŒƒã€å®ç°æ–¹æ¡ˆå’ŒæŠ€æœ¯ç»†èŠ‚ã€‚é€‰æ‹©é¢˜æ¨¡å—é‡‡ç”¨æ·±åº¦é›†æˆæ–¹å¼ï¼Œä½œä¸º Django åº”ç”¨å®Œå…¨èå…¥ä¸»ç³»ç»Ÿï¼Œç¡®ä¿ä¸ç°æœ‰åŠŸèƒ½çš„æ— ç¼åä½œã€‚

### ğŸ¯ å¼€å‘ç›®æ ‡
1. **åŠŸèƒ½å®Œæ•´æ€§**ï¼šæ”¯æŒå•é€‰/å¤šé€‰é¢˜ã€å®æ—¶åˆ¤é¢˜ã€é”™é¢˜è®°å½•ã€ç»Ÿè®¡åˆ†æç­‰æ ¸å¿ƒåŠŸèƒ½
2. **ç³»ç»Ÿä¸€è‡´æ€§**ï¼šUIé£æ ¼ã€æ•°æ®ç»“æ„ã€APIè§„èŒƒä¸ä¸»ç³»ç»Ÿä¿æŒå®Œå…¨ä¸€è‡´
3. **æ€§èƒ½ä¼˜åŒ–**ï¼šé«˜æ•ˆçš„åˆ¤é¢˜ç®—æ³•ã€åˆç†çš„ç¼“å­˜ç­–ç•¥ã€ä¼˜åŒ–çš„æ•°æ®åº“æŸ¥è¯¢
4. **æ‰©å±•æ€§**ï¼šæ¨¡å—åŒ–è®¾è®¡ï¼Œä¾¿äºåç»­åŠŸèƒ½æ‰©å±•å’Œç»´æŠ¤

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„

### æ··åˆé¢˜å‹åˆ¤é¢˜ç³»ç»Ÿè®¾è®¡

æœ¬ç³»ç»Ÿé‡‡ç”¨**ç»Ÿä¸€åˆ¤é¢˜è°ƒåº¦ + åˆ†ç±»å‹å¤„ç†**çš„æ¶æ„æ¨¡å¼ï¼Œå®ç°ç¼–ç¨‹é¢˜ä¸é€‰æ‹©é¢˜çš„ååŒåˆ¤é¢˜ï¼š

#### ğŸ¯ æ ¸å¿ƒè®¾è®¡ç†å¿µ
- **ç»Ÿä¸€å…¥å£**ï¼šæ‰€æœ‰é¢˜ç›®æäº¤éƒ½é€šè¿‡ç»Ÿä¸€çš„åˆ¤é¢˜è°ƒåº¦ç³»ç»Ÿå¤„ç†
- **ç±»å‹è¯†åˆ«**ï¼šæ ¹æ®é¢˜ç›®ç±»å‹è‡ªåŠ¨è·¯ç”±åˆ°ç›¸åº”çš„åˆ¤é¢˜å¼•æ“
- **æ¨¡å—åŒ–å¤„ç†**ï¼šç¼–ç¨‹é¢˜ä½¿ç”¨åŸæœ‰åˆ¤é¢˜ç³»ç»Ÿï¼Œé€‰æ‹©é¢˜ä½¿ç”¨æ–°å¼€å‘çš„åˆ¤é¢˜ç³»ç»Ÿ
- **ç»Ÿä¸€ç®¡ç†**ï¼šæäº¤è®°å½•ã€ç»Ÿè®¡åˆ†æã€ç”¨æˆ·ä½“éªŒä¿æŒä¸€è‡´

#### ğŸ”„ åˆ¤é¢˜æµç¨‹æ¶æ„
```
ç”¨æˆ·æäº¤ç­”æ¡ˆ
     â†“
ç»Ÿä¸€åˆ¤é¢˜è°ƒåº¦å™¨ (JudgeDispatcher)
     â†“
é¢˜ç›®ç±»å‹è¯†åˆ« (QuestionTypeDetector)
     â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ç¼–ç¨‹é¢˜åˆ¤é¢˜     â”‚   é€‰æ‹©é¢˜åˆ¤é¢˜     â”‚
â”‚ (åŸæœ‰ç³»ç»Ÿ)      â”‚ (æ–°å¼€å‘ç³»ç»Ÿ)    â”‚
â”‚                â”‚                â”‚
â”‚ â€¢ ä»£ç ç¼–è¯‘      â”‚ â€¢ ç­”æ¡ˆåŒ¹é…      â”‚
â”‚ â€¢ æµ‹è¯•ç”¨ä¾‹      â”‚ â€¢ å®æ—¶åé¦ˆ      â”‚
â”‚ â€¢ èµ„æºé™åˆ¶      â”‚ â€¢ é”™é¢˜è®°å½•      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â†“
ç»Ÿä¸€ç»“æœå¤„ç† (ResultProcessor)
     â†“
æ›´æ–°æäº¤è®°å½•ã€ç”¨æˆ·ç»Ÿè®¡ã€ç«èµ›æ’å
```

#### ğŸ›ï¸ ç³»ç»Ÿç»„ä»¶
1. **JudgeDispatcher**: åˆ¤é¢˜è°ƒåº¦æ ¸å¿ƒï¼Œè´Ÿè´£ä»»åŠ¡åˆ†å‘
2. **QuestionTypeDetector**: é¢˜ç›®ç±»å‹è¯†åˆ«å™¨
3. **ChoiceQuestionJudge**: é€‰æ‹©é¢˜ä¸“ç”¨åˆ¤é¢˜å¼•æ“
4. **ProgrammingQuestionJudge**: ç¼–ç¨‹é¢˜åˆ¤é¢˜å¼•æ“ï¼ˆå¤ç”¨åŸç³»ç»Ÿï¼‰
5. **ResultProcessor**: ç»Ÿä¸€ç»“æœå¤„ç†å™¨
6. **SubmissionManager**: æäº¤è®°å½•ç»Ÿä¸€ç®¡ç†

### æŠ€æœ¯æ ˆ
- **åç«¯æ¡†æ¶**ï¼šDjango 3.2+ + Django REST Framework
- **æ•°æ®åº“**ï¼šPostgreSQLï¼ˆä¸ä¸»ç³»ç»Ÿå…±äº«ï¼‰
- **ç¼“å­˜**ï¼šRedisï¼ˆå¤ç”¨ä¸»ç³»ç»Ÿå®ä¾‹ï¼‰
- **å‰ç«¯æ¡†æ¶**ï¼šVue.js 2.x + Element UI
- **çŠ¶æ€ç®¡ç†**ï¼šVuex
- **HTTPå®¢æˆ·ç«¯**ï¼šAxios

### ç›®å½•ç»“æ„
```
OnlineJudge/
â”œâ”€â”€ choice_question/              # é€‰æ‹©é¢˜åº”ç”¨ç›®å½•
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ admin.py                  # Django Admin é…ç½®
â”‚   â”œâ”€â”€ admin_urls.py             # ç®¡ç†ç«¯è·¯ç”±
â”‚   â”œâ”€â”€ apps.py                   # åº”ç”¨é…ç½®
â”‚   â”œâ”€â”€ api/                      # API è§†å›¾å±‚
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ category.py           # åˆ†ç±»ç›¸å…³API
â”‚   â”‚   â”œâ”€â”€ question.py           # é¢˜ç›®ç›¸å…³API
â”‚   â”‚   â”œâ”€â”€ submission.py         # æäº¤è®°å½•API
â”‚   â”‚   â””â”€â”€ statistics.py         # ç»Ÿè®¡åˆ†æAPI
â”‚   â”œâ”€â”€ models/                   # æ•°æ®æ¨¡å‹å±‚
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ base.py               # åŸºç¡€æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ question.py           # é¢˜ç›®æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ category.py           # åˆ†ç±»æ¨¡å‹
â”‚   â”‚   â””â”€â”€ submission.py         # æäº¤è®°å½•æ¨¡å‹
â”‚   â”œâ”€â”€ serializers.py            # DRF åºåˆ—åŒ–å™¨
â”‚   â”œâ”€â”€ urls.py                   # API è·¯ç”±é…ç½®
â”‚   â”œâ”€â”€ views.py                  # è§†å›¾å‡½æ•°
â”‚   â”œâ”€â”€ utils/                    # å·¥å…·å‡½æ•°
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ judge.py              # åˆ¤é¢˜é€»è¾‘
â”‚   â”‚   â”œâ”€â”€ importer.py           # é¢˜ç›®å¯¼å…¥
â”‚   â”‚   â””â”€â”€ exporter.py           # é¢˜ç›®å¯¼å‡º
â”‚   â”œâ”€â”€ migrations/               # æ•°æ®åº“è¿ç§»æ–‡ä»¶
â”‚   â””â”€â”€ tests/                    # å•å…ƒæµ‹è¯•
â”‚
OnlineJudgeFE/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ pages/
â”‚   â”‚   â”œâ”€â”€ oj/
â”‚   â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ choice/       # é€‰æ‹©é¢˜ç»„ä»¶
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ QuestionCard.vue
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ CategoryTree.vue
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ StatisticsChart.vue
â”‚   â”‚   â”‚   â””â”€â”€ views/
â”‚   â”‚   â”‚       â””â”€â”€ choice/       # é€‰æ‹©é¢˜é¡µé¢
â”‚   â”‚   â”‚           â”œâ”€â”€ ChoiceQuestionList.vue
â”‚   â”‚   â”‚           â”œâ”€â”€ ChoiceQuestionDetail.vue
â”‚   â”‚   â”‚           â””â”€â”€ WrongQuestionBook.vue
â”‚   â”‚   â””â”€â”€ admin/
â”‚   â”‚       â””â”€â”€ views/
â”‚   â”‚           â””â”€â”€ choice/       # ç®¡ç†ç«¯é¡µé¢
â”‚   â”œâ”€â”€ store/
â”‚   â”‚   â””â”€â”€ modules/
â”‚   â”‚       â””â”€â”€ choice.js         # é€‰æ‹©é¢˜çŠ¶æ€ç®¡ç†
â”‚   â””â”€â”€ api/
â”‚       â””â”€â”€ choice.js             # é€‰æ‹©é¢˜APIå°è£…
```

## ğŸ“Š æ•°æ®æ¨¡å‹è®¾è®¡

### æ ¸å¿ƒæ¨¡å‹å…³ç³»
```
User (Djangoå†…ç½®)
  â†“ (ä¸€å¯¹å¤š)
ChoiceQuestionSubmission (æäº¤è®°å½•)
  â†“ (å¤šå¯¹ä¸€)
ChoiceQuestion (é€‰æ‹©é¢˜)
  â†“ (å¤šå¯¹ä¸€)
ChoiceQuestionCategory (åˆ†ç±»)

ChoiceQuestion â†â†’ ChoiceQuestionTag (å¤šå¯¹å¤š)
```

### é€‰æ‹©é¢˜æ¨¡å‹ (ChoiceQuestion)
```python
class ChoiceQuestion(PluginBaseModel):
    """
    é€‰æ‹©é¢˜æ¨¡å‹
    """
    # åŸºæœ¬ä¿¡æ¯
    _id = models.CharField(
        max_length=32, 
        db_index=True, 
        verbose_name="æ˜¾ç¤ºID",
        help_text="é¢˜ç›®çš„æ˜¾ç¤ºIDï¼Œç”¨äºå‰ç«¯å±•ç¤º"
    )
    
    title = models.TextField(
        verbose_name="é¢˜ç›®æ ‡é¢˜",
        help_text="é¢˜ç›®çš„æ ‡é¢˜æˆ–é—®é¢˜æè¿°"
    )
    
    description = RichTextField(
        verbose_name="é¢˜ç›®æè¿°",
        help_text="é¢˜ç›®çš„è¯¦ç»†æè¿°ï¼Œæ”¯æŒå¯Œæ–‡æœ¬æ ¼å¼"
    )
    
    # é¢˜ç›®ç±»å‹
    QUESTION_TYPE_CHOICES = [
        ('single', 'å•é€‰é¢˜'),
        ('multiple', 'å¤šé€‰é¢˜'),
    ]
    
    question_type = models.CharField(
        max_length=10, 
        choices=QUESTION_TYPE_CHOICES,
        verbose_name="é¢˜ç›®ç±»å‹"
    )
    
    # é€‰é¡¹å’Œç­”æ¡ˆ
    options = JSONField(
        verbose_name="é€‰é¡¹åˆ—è¡¨",
        help_text="æ ¼å¼: [{\"key\": \"A\", \"text\": \"é€‰é¡¹å†…å®¹\"}, ...]"
    )
    
    correct_answer = models.CharField(
        max_length=10, 
        verbose_name="æ­£ç¡®ç­”æ¡ˆ",
        help_text="å•é€‰é¢˜æ ¼å¼: Aï¼Œå¤šé€‰é¢˜æ ¼å¼: A,B,C"
    )
    
    explanation = RichTextField(
        blank=True, 
        verbose_name="ç­”æ¡ˆè§£æ",
        help_text="é¢˜ç›®ç­”æ¡ˆçš„è¯¦ç»†è§£æ"
    )
    
    # åˆ†ç±»å’Œæ ‡ç­¾
    category = models.ForeignKey(
        ChoiceQuestionCategory,
        on_delete=models.SET_NULL, 
        null=True,
        verbose_name="æ‰€å±åˆ†ç±»"
    )
    
    tags = models.ManyToManyField(
        ChoiceQuestionTag,
        blank=True,
        verbose_name="æ ‡ç­¾"
    )
    
    # éš¾åº¦å’Œåˆ†å€¼
    DIFFICULTY_CHOICES = [
        ('easy', 'ç®€å•'),
        ('medium', 'ä¸­ç­‰'),
        ('hard', 'å›°éš¾'),
    ]
    
    difficulty = models.CharField(
        max_length=10,
        choices=DIFFICULTY_CHOICES,
        default='medium',
        verbose_name="éš¾åº¦ç­‰çº§"
    )
    
    score = models.IntegerField(
        default=10,
        validators=[MinValueValidator(1), MaxValueValidator(100)],
        verbose_name="é¢˜ç›®åˆ†å€¼"
    )
    
    # ç»Ÿè®¡ä¿¡æ¯
    total_submit = models.IntegerField(
        default=0, 
        verbose_name="æ€»æäº¤æ¬¡æ•°"
    )
    
    total_accepted = models.IntegerField(
        default=0, 
        verbose_name="æ­£ç¡®æäº¤æ¬¡æ•°"
    )
    
    # åˆ›å»ºè€…
    created_by = models.ForeignKey(
        User, 
        on_delete=models.SET_NULL,
        null=True, 
        related_name="created_choice_questions",
        verbose_name="åˆ›å»ºè€…"
    )
    
    # å¯è§æ€§æ§åˆ¶
    visible = models.BooleanField(
        default=True, 
        verbose_name="æ˜¯å¦å¯è§"
    )
    
    is_public = models.BooleanField(
        default=True,
        verbose_name="æ˜¯å¦å…¬å¼€",
        help_text="æ˜¯å¦å¯¹æ‰€æœ‰ç”¨æˆ·å…¬å¼€"
    )
    
    class Meta:
        db_table = "choice_question"
        verbose_name = "é€‰æ‹©é¢˜"
        verbose_name_plural = "é€‰æ‹©é¢˜"
        ordering = ['-create_time']
        
    def __str__(self):
        return f"{self._id}: {self.title[:50]}"
    
    @property
    def acceptance_rate(self):
        """è®¡ç®—æ­£ç¡®ç‡"""
        if self.total_submit == 0:
            return 0
        return round((self.total_accepted / self.total_submit) * 100, 2)
    
    def get_options_list(self):
        """è·å–é€‰é¡¹åˆ—è¡¨"""
        if isinstance(self.options, str):
            return json.loads(self.options)
        return self.options or []
    
    def get_correct_answer_list(self):
        """è·å–æ­£ç¡®ç­”æ¡ˆåˆ—è¡¨"""
        if not self.correct_answer:
            return []
        return [ans.strip() for ans in self.correct_answer.split(',')]
    
    def check_answer(self, user_answer):
        """æ£€æŸ¥ç”¨æˆ·ç­”æ¡ˆæ˜¯å¦æ­£ç¡®"""
        correct_answers = set(self.get_correct_answer_list())
        if isinstance(user_answer, str):
            user_answers = set([user_answer.strip()])
        else:
            user_answers = set([str(ans).strip() for ans in user_answer])
        return user_answers == correct_answers
    
    def update_statistics(self, is_correct):
        """æ›´æ–°ç»Ÿè®¡ä¿¡æ¯"""
        self.total_submit += 1
        if is_correct:
            self.total_accepted += 1
        self.save(update_fields=['total_submit', 'total_accepted'])
```

### æäº¤è®°å½•æ¨¡å‹ (ChoiceQuestionSubmission)
```python
class ChoiceQuestionSubmission(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    question = models.ForeignKey(ChoiceQuestion, on_delete=models.CASCADE)
    selected_options = models.JSONField()  # ç”¨æˆ·é€‰æ‹©çš„é€‰é¡¹
    is_correct = models.BooleanField()  # æ˜¯å¦æ­£ç¡®
    score = models.FloatField(default=0)  # å¾—åˆ†ï¼ˆå¤šé€‰é¢˜éƒ¨åˆ†å¾—åˆ†ï¼‰
    submit_time = models.DateTimeField(auto_now_add=True)
    ip_address = models.GenericIPAddressField()
    
    class Meta:
        db_table = 'choice_question_submission'
        unique_together = ['user', 'question']  # æ¯é¢˜åªèƒ½æäº¤ä¸€æ¬¡
```

## âš¡ åˆ¤é¢˜ç³»ç»Ÿè®¾è®¡

### åˆ¤é¢˜æµç¨‹
```
ç”¨æˆ·æäº¤ç­”æ¡ˆ â†’ å‚æ•°éªŒè¯ â†’ åˆ¤é¢˜é€»è¾‘ â†’ ç»“æœå­˜å‚¨ â†’ ç»Ÿè®¡æ›´æ–° â†’ è¿”å›ç»“æœ
```

### æ ¸å¿ƒåˆ¤é¢˜ç®—æ³•
```python
class ChoiceQuestionJudge:
    """
    é€‰æ‹©é¢˜åˆ¤é¢˜å·¥å…·ç±»
    è´Ÿè´£é€‰æ‹©é¢˜çš„è‡ªåŠ¨åˆ¤åˆ†é€»è¾‘
    """
    
    def __init__(self):
        self.judge_result = {
            'is_correct': False,
            'score': 0,
            'max_score': 0,
            'user_answer': [],
            'correct_answer': [],
            'explanation': '',
            'judge_time': None,
            'details': {}
        }
    
    def judge_submission(self, question: ChoiceQuestion, user_answer: Union[str, List], 
                        user=None, save_submission: bool = True) -> Dict[str, Any]:
        """
        åˆ¤æ–­ç”¨æˆ·æäº¤çš„ç­”æ¡ˆ
        
        Args:
            question: é¢˜ç›®å¯¹è±¡
            user_answer: ç”¨æˆ·ç­”æ¡ˆ
            user: ç”¨æˆ·å¯¹è±¡
            save_submission: æ˜¯å¦ä¿å­˜æäº¤è®°å½•
            
        Returns:
            åˆ¤é¢˜ç»“æœ
        """
        try:
            # è§£æç”¨æˆ·ç­”æ¡ˆ
            parsed_user_answer = self._parse_user_answer(user_answer, question.question_type)
            
            # è§£ææ­£ç¡®ç­”æ¡ˆ
            correct_answer = self._parse_correct_answer(question.correct_answer)
            
            # æ‰§è¡Œåˆ¤é¢˜
            is_correct = self._compare_answers(parsed_user_answer, correct_answer, question.question_type)
            
            # è®¡ç®—å¾—åˆ†
            score = self._calculate_score(is_correct, question.score, question.question_type, 
                                        parsed_user_answer, correct_answer)
            
            # æ„å»ºåˆ¤é¢˜ç»“æœ
            self.judge_result = {
                'is_correct': is_correct,
                'score': score,
                'max_score': question.score,
                'user_answer': parsed_user_answer,
                'correct_answer': correct_answer,
                'explanation': question.explanation or '',
                'judge_time': timezone.now(),
                'details': {
                    'question_type': question.question_type,
                    'question_id': question.id,
                    'difficulty': question.difficulty,
                    'options_count': len(question.options) if question.options else 0
                }
            }
            
            # ä¿å­˜æäº¤è®°å½•
            if save_submission and user:
                self._save_submission(question, user, parsed_user_answer, is_correct, score)
            
            return self.judge_result
            
        except Exception as e:
            return {
                'is_correct': False,
                'score': 0,
                'max_score': question.score,
                'user_answer': [],
                'correct_answer': [],
                'explanation': '',
                'judge_time': timezone.now(),
                'error': str(e),
                'details': {}
            }
    
    def batch_judge(self, submissions: List[Dict[str, Any]], save_submissions: bool = True) -> List[Dict[str, Any]]:
        """
        æ‰¹é‡åˆ¤é¢˜
        
        Args:
            submissions: æäº¤åˆ—è¡¨ï¼Œæ¯ä¸ªå…ƒç´ åŒ…å«question_id, user_answer, userç­‰
            save_submissions: æ˜¯å¦ä¿å­˜æäº¤è®°å½•
            
        Returns:
            åˆ¤é¢˜ç»“æœåˆ—è¡¨
        """
        results = []
        for submission in submissions:
            try:
                question = ChoiceQuestion.objects.get(id=submission['question_id'])
                result = self.judge_submission(
                    question, 
                    submission['user_answer'], 
                    submission.get('user'),
                    save_submissions
                )
                results.append(result)
            except Exception as e:
                results.append({
                    'is_correct': False,
                    'score': 0,
                    'error': str(e),
                    'question_id': submission.get('question_id')
                })
        return results
    
    def judge_single_choice(self, question, selected_options):
        """
        å•é€‰é¢˜åˆ¤é¢˜
        """
        correct_options = [opt['key'] for opt in question.options if opt.get('is_correct')]
        
        if len(selected_options) != 1:
            return False, 0
            
        return selected_options[0] in correct_options, 1 if selected_options[0] in correct_options else 0
    
    def judge_multiple_choice(self, question, selected_options):
        """
        å¤šé€‰é¢˜åˆ¤é¢˜ï¼ˆæ”¯æŒéƒ¨åˆ†å¾—åˆ†ï¼‰
        """
        correct_options = set(opt['key'] for opt in question.options if opt.get('is_correct'))
        selected_set = set(selected_options)
        
        # å®Œå…¨æ­£ç¡®
        if selected_set == correct_options:
            return True, 1.0
        
        # éƒ¨åˆ†æ­£ç¡®ï¼ˆé€‰å¯¹çš„é€‰é¡¹æ•° / æ€»æ­£ç¡®é€‰é¡¹æ•°ï¼‰
        correct_selected = selected_set & correct_options
        wrong_selected = selected_set - correct_options
        
        # æœ‰é”™é€‰åˆ™ä¸å¾—åˆ†
        if wrong_selected:
            return False, 0
        
        # åªæœ‰å¯¹çš„é€‰æ‹©ï¼ŒæŒ‰æ¯”ä¾‹å¾—åˆ†
        if correct_selected:
            score = len(correct_selected) / len(correct_options)
            return len(correct_selected) == len(correct_options), score
        
        return False, 0
    
    def judge(self, question, selected_options):
        """
        ç»Ÿä¸€åˆ¤é¢˜å…¥å£
        """
        if question.question_type == 'single':
            return self.judge_single_choice(question, selected_options)
        elif question.question_type == 'multiple':
            return self.judge_multiple_choice(question, selected_options)
        else:
            raise ValueError(f"ä¸æ”¯æŒçš„é¢˜ç›®ç±»å‹: {question.question_type}")
    
    def _parse_user_answer(self, user_answer: Union[str, List], question_type: str) -> List[str]:
        """
        è§£æç”¨æˆ·ç­”æ¡ˆ
        
        Args:
            user_answer: ç”¨æˆ·ç­”æ¡ˆï¼ˆå­—ç¬¦ä¸²æˆ–åˆ—è¡¨ï¼‰
            question_type: é¢˜ç›®ç±»å‹
            
        Returns:
            é€‰é¡¹é”®åˆ—è¡¨
        """
        if not user_answer:
            return []
        
        # å¤„ç†ä¸åŒæ ¼å¼çš„ç”¨æˆ·ç­”æ¡ˆ
        if isinstance(user_answer, str):
            if question_type == 'single':
                answers = [user_answer.strip()]
            else:
                answers = [ans.strip() for ans in user_answer.split(',') if ans.strip()]
        elif isinstance(user_answer, list):
            answers = [str(ans).strip() for ans in user_answer if str(ans).strip()]
        else:
            return []
        
        return answers
    
    def _parse_correct_answer(self, answer: str) -> List[str]:
        """
        è§£ææ­£ç¡®ç­”æ¡ˆ
        
        Args:
            answer: æ­£ç¡®ç­”æ¡ˆå­—ç¬¦ä¸²
            
        Returns:
            æ­£ç¡®ç­”æ¡ˆé”®åˆ—è¡¨
        """
        if not answer:
            return []
        
        # åˆ†å‰²ç­”æ¡ˆ
        answers = [ans.strip() for ans in answer.split(',') if ans.strip()]
        return answers
    
    def _compare_answers(self, user_answer: List[str], correct_answer: List[str], 
                       question_type: str) -> bool:
        """
        æ¯”è¾ƒç”¨æˆ·ç­”æ¡ˆå’Œæ­£ç¡®ç­”æ¡ˆ
        
        Args:
            user_answer: ç”¨æˆ·ç­”æ¡ˆé”®åˆ—è¡¨
            correct_answer: æ­£ç¡®ç­”æ¡ˆé”®åˆ—è¡¨
            question_type: é¢˜ç›®ç±»å‹
            
        Returns:
            æ˜¯å¦æ­£ç¡®
        """
        if question_type == 'single':
            # å•é€‰é¢˜ï¼šåªèƒ½æœ‰ä¸€ä¸ªç­”æ¡ˆ
            if len(user_answer) != 1 or len(correct_answer) != 1:
                return False
            return user_answer[0] == correct_answer[0]
        else:
            # å¤šé€‰é¢˜ï¼šç­”æ¡ˆé›†åˆå¿…é¡»å®Œå…¨åŒ¹é…
            return set(user_answer) == set(correct_answer)
    
    def _calculate_score(self, is_correct: bool, max_score: int, question_type: str,
                        user_answer: List[str], correct_answer: List[str]) -> int:
        """
        è®¡ç®—å¾—åˆ†
        
        Args:
            is_correct: æ˜¯å¦å®Œå…¨æ­£ç¡®
            max_score: æ»¡åˆ†
            question_type: é¢˜ç›®ç±»å‹
            user_answer: ç”¨æˆ·ç­”æ¡ˆ
            correct_answer: æ­£ç¡®ç­”æ¡ˆ
            
        Returns:
            å¾—åˆ†
        """
        if is_correct:
            return max_score
        
        # å¤šé€‰é¢˜éƒ¨åˆ†åˆ†æ•°è®¡ç®—ï¼ˆå¯é€‰ï¼‰
        if question_type == 'multiple' and user_answer and correct_answer:
            correct_count = len(set(user_answer) & set(correct_answer))
            wrong_count = len(set(user_answer) - set(correct_answer))
            total_correct = len(correct_answer)
            
            # éƒ¨åˆ†åˆ†æ•° = (æ­£ç¡®é€‰é¡¹æ•° - é”™è¯¯é€‰é¡¹æ•°) / æ€»æ­£ç¡®é€‰é¡¹æ•° * æ»¡åˆ†
            if total_correct > 0:
                partial_score = max(0, (correct_count - wrong_count) / total_correct * max_score)
                return int(partial_score)
        
        return 0
    
    def _save_submission(self, question: ChoiceQuestion, user, user_answer: List[str], 
                        is_correct: bool, score: int):
        """
        ä¿å­˜æäº¤è®°å½•
        
        Args:
            question: é¢˜ç›®å¯¹è±¡
            user: ç”¨æˆ·å¯¹è±¡
            user_answer: ç”¨æˆ·ç­”æ¡ˆ
            is_correct: æ˜¯å¦æ­£ç¡®
            score: å¾—åˆ†
        """
        from ..models import ChoiceQuestionSubmission
        
        # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨æäº¤è®°å½•
        existing_submission = ChoiceQuestionSubmission.objects.filter(
            user=user, question=question
        ).first()
        
        if existing_submission:
            # æ›´æ–°ç°æœ‰è®°å½•
            existing_submission.user_answer = user_answer
            existing_submission.is_correct = is_correct
            existing_submission.score = score
            existing_submission.submit_time = timezone.now()
            existing_submission.save()
        else:
            # åˆ›å»ºæ–°è®°å½•
            ChoiceQuestionSubmission.objects.create(
                user=user,
                question=question,
                user_answer=user_answer,
                is_correct=is_correct,
                score=score
            )
```

### API æ¥å£è®¾è®¡

#### é€‰æ‹©é¢˜åˆ—è¡¨æ¥å£

```python
class ChoiceQuestionAPI(APIView):
    """
    é€‰æ‹©é¢˜API
    """
    
    def get(self, request):
        """
        è·å–é€‰æ‹©é¢˜åˆ—è¡¨
        """
        # è·å–æŸ¥è¯¢å‚æ•°
        category_id = request.GET.get('category')
        difficulty = request.GET.get('difficulty')
        tag_ids = request.GET.get('tags', '').split(',') if request.GET.get('tags') else []
        keyword = request.GET.get('keyword', '').strip()
        is_public = request.GET.get('is_public')
        
        # æ„å»ºæŸ¥è¯¢æ¡ä»¶
        queryset = ChoiceQuestion.objects.filter(visible=True)
        
        # åˆ†ç±»ç­›é€‰
        if category_id:
            try:
                category = Category.objects.get(id=category_id)
                # åŒ…å«å­åˆ†ç±»çš„é¢˜ç›®
                categories = category.get_descendants(include_self=True)
                queryset = queryset.filter(category__in=categories)
            except Category.DoesNotExist:
                pass
        
        # éš¾åº¦ç­›é€‰
        if difficulty and difficulty in ['easy', 'medium', 'hard']:
            queryset = queryset.filter(difficulty=difficulty)
        
        # æ ‡ç­¾ç­›é€‰
        if tag_ids and tag_ids != ['']:
            try:
                tag_ids = [int(tag_id) for tag_id in tag_ids if tag_id.isdigit()]
                if tag_ids:
                    queryset = queryset.filter(tags__id__in=tag_ids).distinct()
            except ValueError:
                pass
        
        # å…³é”®è¯æœç´¢
        if keyword:
            queryset = queryset.filter(
                Q(title__icontains=keyword) |
                Q(description__icontains=keyword) |
                Q(_id__icontains=keyword)
            )
        
        # æƒé™æ§åˆ¶
        if not request.user.is_authenticated or not request.user.is_admin():
            queryset = queryset.filter(is_public=True)
        
        # æ’åº
        queryset = queryset.select_related('category', 'created_by').prefetch_related('tags')
        
        return self.success(self.paginate_data(request, queryset, ChoiceQuestionListSerializer))
    
    @super_admin_required
    @validate_serializer(ChoiceQuestionCreateSerializer)
    def post(self, request):
        """
        åˆ›å»ºé€‰æ‹©é¢˜
        """
        data = request.data
        data['created_by'] = request.user.id
        
        # ç”Ÿæˆæ˜¾ç¤ºID
        if not data.get('_id'):
            data['_id'] = self._generate_question_id()
        
        serializer = ChoiceQuestionCreateSerializer(data=data)
        if serializer.is_valid():
            question = serializer.save()
            return self.success(ChoiceQuestionDetailSerializer(question).data)
        
        return self.error("å‚æ•°é”™è¯¯", serializer.errors)
```

#### é€‰æ‹©é¢˜è¯¦æƒ…æ¥å£

```python
class ChoiceQuestionDetailAPI(APIView):
    """
    é€‰æ‹©é¢˜è¯¦æƒ…API
    """
    
    def get(self, request, question_id):
        """
        è·å–é€‰æ‹©é¢˜è¯¦æƒ…
        """
        try:
            question = ChoiceQuestion.objects.select_related('category', 'created_by').prefetch_related('tags').get(_id=question_id, visible=True)
        except ChoiceQuestion.DoesNotExist:
            return self.error("é¢˜ç›®ä¸å­˜åœ¨")
        
        # æƒé™æ£€æŸ¥
        if not question.is_public and (not request.user.is_authenticated or not request.user.is_admin()):
            return self.error("æ— æƒé™è®¿é—®")
        
        return self.success(ChoiceQuestionDetailSerializer(question).data)
```

#### æäº¤ç­”æ¡ˆæ¥å£

```python
class ChoiceQuestionSubmitAPI(CSRFExemptAPIView):
    """
    é€‰æ‹©é¢˜ç­”æ¡ˆæäº¤API
    """
    
    @login_required
    @validate_serializer(ChoiceQuestionSubmissionCreateSerializer)
    def post(self, request, question_id):
        """
        æäº¤é€‰æ‹©é¢˜ç­”æ¡ˆ
        """
        try:
            question = ChoiceQuestion.objects.get(_id=question_id, visible=True)
        except ChoiceQuestion.DoesNotExist:
            return self.error("é¢˜ç›®ä¸å­˜åœ¨")
        
        # æƒé™æ£€æŸ¥
        if not question.is_public and not request.user.is_admin():
            return self.error("æ— æƒé™è®¿é—®")
        
        user_answer = request.data.get('user_answer')
        
        # åˆ¤é¢˜
        judge = ChoiceQuestionJudge()
        result = judge.judge_submission(question, user_answer, request.user)
        
        # æ›´æ–°é¢˜ç›®ç»Ÿè®¡
        question.update_statistics(result['is_correct'])
        
        return self.success({
            'is_correct': result['is_correct'],
            'score': result['score'],
            'max_score': result['max_score'],
            'correct_answer': result['correct_answer'],
            'explanation': result['explanation'],
            'user_answer': result['user_answer']
        })
```

#### éšæœºé¢˜ç›®æ¥å£

```python
class ChoiceQuestionRandomAPI(APIView):
    """
    éšæœºé€‰æ‹©é¢˜API
    """
    
    def get(self, request):
        """
        è·å–éšæœºé¢˜ç›®
        """
        count = int(request.GET.get('count', 10))
        category_id = request.GET.get('category')
        difficulty = request.GET.get('difficulty')
        
        # é™åˆ¶æ•°é‡
        count = min(count, 50)
        
        questions = ChoiceQuestion.get_random_questions(
            count=count,
            category=category_id,
            difficulty=difficulty
        )
        
        return self.success(ChoiceQuestionListSerializer(questions, many=True).data)
```

#### ç»Ÿè®¡åˆ†ææ¥å£

```python
class ChoiceQuestionStatisticsAPI(APIView):
    """
    é€‰æ‹©é¢˜ç»Ÿè®¡API
    """
    
    @super_admin_required
    def get(self, request, question_id):
        """
        è·å–é¢˜ç›®ç»Ÿè®¡ä¿¡æ¯
        """
        try:
            question = ChoiceQuestion.objects.get(_id=question_id)
        except ChoiceQuestion.DoesNotExist:
            return self.error("é¢˜ç›®ä¸å­˜åœ¨")
        
        calculator = StatisticsCalculator()
        statistics = calculator.get_question_statistics(question)
        
        return self.success(statistics)
```

## ğŸ¨ å‰ç«¯å®ç°

### ç­”é¢˜é¡µé¢ç»„ä»¶ (ChoiceQuestionDetail.vue)
```vue
<template>
  <div class="choice-question-detail">
    <!-- é¢˜ç›®ä¿¡æ¯ -->
    <div class="question-header">
      <h2 v-html="question.title"></h2>
      <div class="question-meta">
        <span class="difficulty">éš¾åº¦: {{ difficultyText }}</span>
        <span class="category">åˆ†ç±»: {{ question.category.name }}</span>
      </div>
    </div>
    
    <!-- é€‰é¡¹åˆ—è¡¨ -->
    <div class="options-container">
      <!-- å•é€‰é¢˜ -->
      <template v-if="question.question_type === 'single'">
        <div 
          v-for="option in question.options" 
          :key="option.key"
          class="option-row"
          :class="{
            'selected': result.answer === option.key,
            'correct': showResult && option.is_correct,
            'wrong': showResult && result.answer === option.key && !option.is_correct
          }"
          @click="selectOption(option.key)"
        >
          <el-radio 
            v-model="result.answer" 
            :label="option.key"
            @click.stop>
          </el-radio>
          <div class="option-content-wrapper">
            <span class="option-key">{{ option.key }}.</span>
            <div class="option-content" v-html="option.content"></div>
          </div>
          <i v-if="showResult && option.is_correct" class="el-icon-check result-icon correct"></i>
          <i v-if="showResult && result.answer === option.key && !option.is_correct" 
             class="el-icon-close result-icon wrong"></i>
        </div>
      </template>
      
      <!-- å¤šé€‰é¢˜ -->
      <template v-else-if="question.question_type === 'multiple'">
        <div 
          v-for="option in question.options" 
          :key="option.key"
          class="option-row"
          :class="{
            'selected': selectedOptions.includes(option.key),
            'correct': showResult && option.is_correct,
            'wrong': showResult && selectedOptions.includes(option.key) && !option.is_correct
          }"
          @click="toggleOption(option.key)"
        >
          <el-checkbox 
            v-model="selectedOptions" 
            :label="option.key"
            @click.stop>
          </el-checkbox>
          <div class="option-content-wrapper">
            <span class="option-key">{{ option.key }}.</span>
            <div class="option-content" v-html="option.content"></div>
          </div>
          <i v-if="showResult && option.is_correct" class="el-icon-check result-icon correct"></i>
          <i v-if="showResult && selectedOptions.includes(option.key) && !option.is_correct" 
             class="el-icon-close result-icon wrong"></i>
        </div>
      </template>
    </div>
    
    <!-- æ“ä½œæŒ‰é’® -->
    <div class="action-buttons">
      <el-button 
        type="primary" 
        :disabled="selectedOptions.length === 0 || submitted"
        @click="submitAnswer"
      >
        {{ submitted ? 'å·²æäº¤' : 'æäº¤ç­”æ¡ˆ' }}
      </el-button>
      
      <el-button v-if="showResult" @click="addToWrongBook">
        åŠ å…¥é”™é¢˜æœ¬
      </el-button>
    </div>
    
    <!-- ç»“æœå±•ç¤º -->
    <div v-if="showResult" class="result-container">
      <div class="result-header" :class="{ 'correct': result.is_correct, 'wrong': !result.is_correct }">
        <i :class="result.is_correct ? 'el-icon-success' : 'el-icon-error'"></i>
        <span>{{ result.is_correct ? 'å›ç­”æ­£ç¡®' : 'å›ç­”é”™è¯¯' }}</span>
        <span class="score">å¾—åˆ†: {{ (result.score * 100).toFixed(0) }}%</span>
      </div>
      
      <div v-if="result.explanation" class="explanation">
        <h4>é¢˜ç›®è§£æï¼š</h4>
        <p>{{ result.explanation }}</p>
      </div>
    </div>
  </div>
</template>

<script>
import { mapActions } from 'vuex'
import api from '@/api/choice'

export default {
  name: 'ChoiceQuestionDetail',
  data() {
    return {
      question: {},
      selectedOptions: [], // å¤šé€‰é¢˜ä½¿ç”¨
      result: { answer: null }, // å•é€‰é¢˜ä½¿ç”¨
      submitted: false,
      showResult: false
    }
  },
  
  computed: {
    difficultyText() {
      const levels = ['', 'ç®€å•', 'è¾ƒæ˜“', 'ä¸­ç­‰', 'è¾ƒéš¾', 'å›°éš¾']
      return levels[this.question.difficulty] || 'æœªçŸ¥'
    }
  },
  

    
    selectOption(optionKey) {
      if (this.submitted) return
      // å•é€‰é¢˜é€‰æ‹©é€»è¾‘
      this.result.answer = optionKey
    },
    
    toggleOption(optionKey) {
      if (this.submitted) return
      // å¤šé€‰é¢˜åˆ‡æ¢é€»è¾‘
      const index = this.selectedOptions.indexOf(optionKey)
      if (index > -1) {
        this.selectedOptions.splice(index, 1)
      } else {
        this.selectedOptions.push(optionKey)
      }
    },
    
    async submitAnswer() {
      try {
        let selectedOptions
        if (this.question.question_type === 'single') {
          selectedOptions = this.result.answer ? [this.result.answer] : []
        } else {
          selectedOptions = this.selectedOptions
        }
        
        const result = await this.submitQuestionAnswer({
          question_id: this.question.id,
          selected_options: selectedOptions
        })
        
        this.result = { ...this.result, ...result }
        this.submitted = true
        this.showResult = true
        
        this.$message.success('æäº¤æˆåŠŸ')
      } catch (error) {
        this.$message.error(error.message || 'æäº¤å¤±è´¥')
      }
    },
    
    async addToWrongBook() {
      if (this.result.is_correct) {
        this.$message.info('æ­£ç¡®ç­”é¢˜æ— éœ€åŠ å…¥é”™é¢˜æœ¬')
        return
      }
      
      try {
        await this.addQuestionToWrongBook(this.question.id)
        this.$message.success('å·²åŠ å…¥é”™é¢˜æœ¬')
      } catch (error) {
        this.$message.error('åŠ å…¥é”™é¢˜æœ¬å¤±è´¥')
      }
    },
    
    async loadQuestion() {
      const questionId = this.$route.params.id
      try {
        const response = await api.getQuestionDetail(questionId)
        this.question = response.data
      } catch (error) {
        this.$message.error('åŠ è½½é¢˜ç›®å¤±è´¥')
        this.$router.go(-1)
      }
    }
  },
  
  created() {
    this.loadQuestion()
  },
  
  mounted() {
    this.$nextTick(() => {
      // æ¸²æŸ“æ•°å­¦å…¬å¼
      this.renderMathFormulas()
      // ä¿®å¤é€‰é¡¹ç‚¹å‡»é—®é¢˜
      this.fixOptionClickability()
    })
  },
  
  methods: {
    ...mapActions('choice', ['submitQuestionAnswer', 'addQuestionToWrongBook']),
    
    fixOptionClickability() {
      // ç¡®ä¿æ‰€æœ‰é€‰é¡¹å†…å®¹ä¸é˜»æ­¢ç‚¹å‡»äº‹ä»¶
      const optionContents = this.$el.querySelectorAll('.option-content')
      optionContents.forEach(content => {
        content.style.pointerEvents = 'none'
      })
    },
    
    renderMathFormulas() {
      // å¦‚æœä½¿ç”¨KaTeXï¼Œåœ¨è¿™é‡Œè¿›è¡Œæ¸²æŸ“
      this.$nextTick(() => {
        const mathElements = this.$el.querySelectorAll('.katex')
        mathElements.forEach(element => {
          // KaTeXæ¸²æŸ“é€»è¾‘
        })
      })
    },
}
</script>

<style scoped>
.choice-question-detail {
  max-width: 800px;
  margin: 0 auto;
  padding: 20px;
}

.question-header {
  margin-bottom: 30px;
  padding-bottom: 20px;
  border-bottom: 1px solid #e8e8e8;
}

.question-header h2 {
  margin: 0 0 10px 0;
  font-size: 18px;
  line-height: 1.6;
}

.question-meta {
  display: flex;
  gap: 20px;
  color: #666;
  font-size: 14px;
}

.options-container {
  margin-bottom: 30px;
}

.option-row {
  display: flex;
  align-items: flex-start;
  padding: 12px;
  margin-bottom: 8px;
  border: 1px solid #dcdfe6;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.3s;
  position: relative;
}

.option-row:hover {
  border-color: #409eff;
  background-color: #f5f7fa;
}

.option-row.selected {
  border-color: #409eff;
  background-color: #f0f9ff;
}

.option-row.correct {
  border-color: #67c23a;
  background-color: #f0f9ff;
}

.option-row.wrong {
  border-color: #f56c6c;
  background-color: #fef0f0;
}

.option-content-wrapper {
  flex: 1;
  margin-left: 8px;
  display: flex;
  align-items: flex-start;
}

.option-key {
  font-weight: bold;
  margin-right: 8px;
  min-width: 20px;
  line-height: 1.5;
}

.option-content {
  flex: 1;
  line-height: 1.5;
}

/* ç¡®ä¿å¤æ‚å†…å®¹ä¸å¹²æ‰°ç‚¹å‡»äº‹ä»¶ */
.option-content * {
  pointer-events: none !important;
}

/* KaTeX ç‰¹æ®Šå¤„ç† */
.option-content .katex {
  font-size: 1em;
}

/* ä»£ç å—ç‰¹æ®Šå¤„ç† */
.option-content pre,
.option-content code {
  background-color: #f5f5f5;
  padding: 2px 4px;
  border-radius: 3px;
  font-family: 'Courier New', monospace;
}

.result-icon {
  position: absolute;
  right: 12px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 16px;
}

.result-icon.correct {
  color: #67c23a;
}

.result-icon.wrong {
  color: #f56c6c;
}

.action-buttons {
  text-align: center;
  margin-bottom: 30px;
}

.result-container {
  padding: 20px;
  border-radius: 6px;
  background-color: #f8f9fa;
}

.result-header {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 15px;
  font-size: 16px;
  font-weight: bold;
}

.result-header.correct {
  color: #67c23a;
}

.result-header.wrong {
  color: #f56c6c;
}

.score {
  margin-left: auto;
}

.explanation {
  padding-top: 15px;
  border-top: 1px solid #e8e8e8;
}

.explanation h4 {
  margin: 0 0 10px 0;
  color: #333;
}

.explanation p {
  margin: 0;
  line-height: 1.6;
  color: #666;
}
</style>
```

### Vuex çŠ¶æ€ç®¡ç†
```javascript
// store/modules/choice.js
import api from '@/api/choice'

const state = {
  questionList: [],
  currentQuestion: null,
  categories: [],
  tags: [],
  statistics: {},
  wrongQuestions: []
}

const mutations = {
  SET_QUESTION_LIST(state, questions) {
    state.questionList = questions
  },
  
  SET_CURRENT_QUESTION(state, question) {
    state.currentQuestion = question
  },
  
  SET_CATEGORIES(state, categories) {
    state.categories = categories
  },
  
  SET_STATISTICS(state, statistics) {
    state.statistics = statistics
  },
  
  ADD_WRONG_QUESTION(state, question) {
    if (!state.wrongQuestions.find(q => q.id === question.id)) {
      state.wrongQuestions.push(question)
    }
  }
}

const actions = {
  async fetchQuestionList({ commit }, params = {}) {
    try {
      const response = await api.getQuestionList(params)
      commit('SET_QUESTION_LIST', response.data.results)
      return response.data
    } catch (error) {
      throw error
    }
  },
  
  async submitQuestionAnswer({ commit }, { question_id, selected_options }) {
    try {
      const response = await api.submitAnswer({
        question_id,
        selected_options
      })
      return response.data
    } catch (error) {
      throw error
    }
  },
  
  async addQuestionToWrongBook({ commit }, questionId) {
    try {
      const response = await api.addToWrongBook(questionId)
      commit('ADD_WRONG_QUESTION', response.data.question)
      return response.data
    } catch (error) {
      throw error
    }
  }
}

export default {
  namespaced: true,
  state,
  mutations,
  actions
}
```

## ğŸ”§ å¼€å‘è§„èŒƒ

### ä»£ç è§„èŒƒ
1. **Pythonä»£ç **ï¼šéµå¾ª PEP 8 è§„èŒƒï¼Œä½¿ç”¨ Black æ ¼å¼åŒ–
2. **JavaScriptä»£ç **ï¼šéµå¾ª ESLint é…ç½®ï¼Œä½¿ç”¨ Prettier æ ¼å¼åŒ–
3. **Vueç»„ä»¶**ï¼šä½¿ç”¨ PascalCase å‘½åï¼Œå•æ–‡ä»¶ç»„ä»¶ç»“æ„æ¸…æ™°
4. **APIæ¥å£**ï¼šRESTful è®¾è®¡ï¼Œç»Ÿä¸€é”™è¯¯å¤„ç†

### æ•°æ®åº“è§„èŒƒ
1. **è¡¨å**ï¼šä½¿ç”¨ä¸‹åˆ’çº¿å‘½åæ³•ï¼Œå¦‚ `choice_question`
2. **å­—æ®µå**ï¼šä½¿ç”¨ä¸‹åˆ’çº¿å‘½åæ³•ï¼Œå¦‚ `created_at`
3. **ç´¢å¼•**ï¼šä¸ºæŸ¥è¯¢é¢‘ç¹çš„å­—æ®µæ·»åŠ ç´¢å¼•
4. **å¤–é”®**ï¼šä½¿ç”¨ CASCADE åˆ é™¤ç­–ç•¥

### API è§„èŒƒ
1. **URLè®¾è®¡**ï¼š`/api/plugin/choice/` å‰ç¼€
2. **HTTPæ–¹æ³•**ï¼šGET(æŸ¥è¯¢)ã€POST(åˆ›å»º)ã€PUT(æ›´æ–°)ã€DELETE(åˆ é™¤)
3. **å“åº”æ ¼å¼**ï¼šç»Ÿä¸€JSONæ ¼å¼ï¼ŒåŒ…å« `code`ã€`message`ã€`data` å­—æ®µ
4. **é”™è¯¯å¤„ç†**ï¼šä½¿ç”¨æ ‡å‡†HTTPçŠ¶æ€ç 

## ğŸ§ª æµ‹è¯•ç­–ç•¥

### åç«¯æµ‹è¯•
```python
# tests/test_judge.py
from django.test import TestCase
from choice_question.utils.judge import ChoiceQuestionJudge
from choice_question.models import ChoiceQuestion

class JudgeTestCase(TestCase):
    def setUp(self):
        self.judge = ChoiceQuestionJudge()
        self.single_question = ChoiceQuestion.objects.create(
            title="æµ‹è¯•å•é€‰é¢˜",
            question_type="single",
            options=[
                {"id": "A", "content": "é€‰é¡¹A", "is_correct": True},
                {"id": "B", "content": "é€‰é¡¹B", "is_correct": False},
                {"id": "C", "content": "é€‰é¡¹C", "is_correct": False}
            ]
        )
    
    def test_single_choice_correct(self):
        is_correct, score = self.judge.judge(self.single_question, ["A"])
        self.assertTrue(is_correct)
        self.assertEqual(score, 1)
    
    def test_single_choice_wrong(self):
        is_correct, score = self.judge.judge(self.single_question, ["B"])
        self.assertFalse(is_correct)
        self.assertEqual(score, 0)
```

### å‰ç«¯æµ‹è¯•
```javascript
// tests/unit/ChoiceQuestionDetail.spec.js
import { shallowMount } from '@vue/test-utils'
import ChoiceQuestionDetail from '@/pages/oj/views/choice/ChoiceQuestionDetail.vue'

describe('ChoiceQuestionDetail.vue', () => {
  it('renders question title', () => {
    const question = {
      title: 'æµ‹è¯•é¢˜ç›®',
      options: []
    }
    const wrapper = shallowMount(ChoiceQuestionDetail, {
      data() {
        return { question }
      }
    })
    expect(wrapper.find('h2').text()).toBe('æµ‹è¯•é¢˜ç›®')
  })
})
```

## ğŸ“ˆ æ€§èƒ½ä¼˜åŒ–

### æ•°æ®åº“ä¼˜åŒ–
1. **ç´¢å¼•ä¼˜åŒ–**ï¼šä¸ºå¸¸ç”¨æŸ¥è¯¢å­—æ®µæ·»åŠ ç´¢å¼•
2. **æŸ¥è¯¢ä¼˜åŒ–**ï¼šä½¿ç”¨ `select_related` å’Œ `prefetch_related`
3. **åˆ†é¡µæŸ¥è¯¢**ï¼šå¤§æ•°æ®é‡ä½¿ç”¨æ¸¸æ ‡åˆ†é¡µ

### ç¼“å­˜ç­–ç•¥
1. **é¢˜ç›®ç¼“å­˜**ï¼šçƒ­é—¨é¢˜ç›®ç¼“å­˜åˆ° Redis
2. **ç»Ÿè®¡ç¼“å­˜**ï¼šç”¨æˆ·ç»Ÿè®¡æ•°æ®ç¼“å­˜
3. **åˆ†ç±»ç¼“å­˜**ï¼šåˆ†ç±»æ ‘ç»“æ„ç¼“å­˜

### å‰ç«¯ä¼˜åŒ–
1. **ç»„ä»¶æ‡’åŠ è½½**ï¼šè·¯ç”±çº§åˆ«çš„ä»£ç åˆ†å‰²
2. **å›¾ç‰‡ä¼˜åŒ–**ï¼šé¢˜ç›®å›¾ç‰‡å‹ç¼©å’ŒCDN
3. **è¯·æ±‚ä¼˜åŒ–**ï¼šé˜²æŠ–ã€èŠ‚æµã€è¯·æ±‚åˆå¹¶

## ğŸš€ éƒ¨ç½²æŒ‡å—

### å¼€å‘ç¯å¢ƒ
```bash
# åç«¯
cd OnlineJudge
python manage.py makemigrations choice_question
python manage.py migrate
python manage.py runserver

# å‰ç«¯
cd OnlineJudgeFE
npm install
npm run dev
```

### ç”Ÿäº§ç¯å¢ƒ
```bash
# æ•°æ®åº“è¿ç§»
python manage.py migrate choice_question

# é™æ€æ–‡ä»¶æ”¶é›†
python manage.py collectstatic

# é‡å¯æœåŠ¡
sudo systemctl restart gunicorn
sudo systemctl restart nginx
```

## ğŸ“ API æ–‡æ¡£

### é¢˜ç›®ç›¸å…³æ¥å£

#### è·å–é¢˜ç›®åˆ—è¡¨
- **URL**: `GET /api/plugin/choice/questions/`
- **å‚æ•°**:
  - `page`: é¡µç 
  - `page_size`: æ¯é¡µæ•°é‡
  - `category`: åˆ†ç±»ID
  - `tags`: æ ‡ç­¾IDåˆ—è¡¨
  - `difficulty`: éš¾åº¦ç­‰çº§
- **å“åº”**:
```json
{
  "code": 0,
  "message": "success",
  "data": {
    "total": 100,
    "results": [
      {
        "id": 1,
        "title": "é¢˜ç›®æ ‡é¢˜",
        "difficulty": 2,
        "category": {
          "id": 1,
          "name": "åˆ†ç±»åç§°"
        },
        "tags": [
          {"id": 1, "name": "æ ‡ç­¾1"}
        ]
      }
    ]
  }
}
```

#### è·å–é¢˜ç›®è¯¦æƒ…
- **URL**: `GET /api/plugin/choice/questions/{id}/`
- **å“åº”**:
```json
{
  "code": 0,
  "message": "success",
  "data": {
    "id": 1,
    "title": "é¢˜ç›®å†…å®¹",
    "question_type": "single",
    "options": [
      {
        "key": "A",
        "content": "é€‰é¡¹å†…å®¹",
        "is_correct": false
      }
    ],
    "difficulty": 2,
    "category": {
      "id": 1,
      "name": "åˆ†ç±»åç§°"
    }
  }
}
```

#### æäº¤ç­”æ¡ˆ
- **URL**: `POST /api/plugin/choice/submissions/`
- **å‚æ•°**:
```json
{
  "question_id": 1,
  "selected_options": ["A"]
}
```
- **å“åº”**:
```json
{
  "code": 0,
  "message": "success",
  "data": {
    "is_correct": true,
    "score": 1.0,
    "explanation": "é¢˜ç›®è§£æ",
    "correct_options": ["A"]
  }
}
```

## ğŸ”§ å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

### é€‰é¡¹å†…å®¹æ¸²æŸ“é—®é¢˜

#### é—®é¢˜æè¿°
å½“é€‰é¡¹åŒ…å«æ•°å­¦å…¬å¼ï¼ˆKaTeXï¼‰ã€ä»£ç é«˜äº®æˆ–å…¶ä»–å¤æ‚HTMLå†…å®¹æ—¶ï¼Œå¯èƒ½å‡ºç°é€‰é¡¹æ— æ³•ç‚¹å‡»çš„é—®é¢˜ã€‚è¿™æ˜¯å› ä¸ºï¼š
1. Element UIç»„ä»¶å†…éƒ¨ä½¿ç”¨v-htmlæ¸²æŸ“å¤æ‚å†…å®¹æ—¶ï¼ŒDOMäº‹ä»¶ä¼ æ’­è¢«é˜»æ–­
2. KaTeXå’Œä»£ç é«˜äº®ç”Ÿæˆçš„å…ƒç´ å±‚çº§è¾ƒé«˜ï¼Œè¦†ç›–äº†ç‚¹å‡»åŒºåŸŸ
3. å¤æ‚DOMç»“æ„å¹²æ‰°äº†è¡¨å•ç»„ä»¶çš„æ­£å¸¸äº‹ä»¶å¤„ç†

#### è§£å†³æ–¹æ¡ˆ

**1. DOMäº‹ä»¶ç©¿é€å¤„ç†**
```css
/* ç¡®ä¿é€‰é¡¹å†…å®¹ä¸é˜»æ­¢çˆ¶å…ƒç´ äº‹ä»¶ */
.option-content * {
  pointer-events: none !important;
}

/* ä¿æŒé€‰é¡¹å®¹å™¨å¯ç‚¹å‡» */
.option-row {
  pointer-events: auto;
  cursor: pointer;
}
```

**2. æ¨èçš„é€‰é¡¹ç»“æ„**
```vue
<template>
  <!-- å•é€‰é¢˜æ¨èç»“æ„ -->
  <div class="option-row" @click="selectOption(option.key)">
    <el-radio 
      v-model="result.answer" 
      :label="option.key"
      @click.stop>
    </el-radio>
    <div class="option-content-wrapper">
      <span class="option-key">{{ option.key }}.</span>
      <div class="option-content" v-html="option.content"></div>
    </div>
  </div>
  
  <!-- å¤šé€‰é¢˜æ¨èç»“æ„ -->
  <div class="option-row" @click="toggleOption(option.key)">
    <el-checkbox 
      v-model="selectedOptions" 
      :label="option.key"
      @click.stop>
    </el-checkbox>
    <div class="option-content-wrapper">
      <span class="option-key">{{ option.key }}.</span>
      <div class="option-content" v-html="option.content"></div>
    </div>
  </div>
</template>

<script>
export default {
  methods: {
    selectOption(optionKey) {
      // å•é€‰é¢˜é€‰æ‹©é€»è¾‘
      this.result.answer = optionKey
    },
    
    toggleOption(optionKey) {
      // å¤šé€‰é¢˜åˆ‡æ¢é€»è¾‘
      const index = this.selectedOptions.indexOf(optionKey)
      if (index > -1) {
        this.selectedOptions.splice(index, 1)
      } else {
        this.selectedOptions.push(optionKey)
      }
    }
  }
}
</script>

<style scoped>
.option-row {
  display: flex;
  align-items: flex-start;
  padding: 12px;
  margin-bottom: 8px;
  border: 1px solid #dcdfe6;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.3s;
}

.option-row:hover {
  border-color: #409eff;
  background-color: #f5f7fa;
}

.option-content-wrapper {
  flex: 1;
  margin-left: 8px;
  display: flex;
  align-items: flex-start;
}

.option-key {
  font-weight: bold;
  margin-right: 8px;
  min-width: 20px;
  line-height: 1.5;
}

.option-content {
  flex: 1;
  line-height: 1.5;
}

/* ç¡®ä¿å¤æ‚å†…å®¹ä¸å¹²æ‰°ç‚¹å‡»äº‹ä»¶ */
.option-content * {
  pointer-events: none !important;
}

/* KaTeX ç‰¹æ®Šå¤„ç† */
.option-content .katex {
  font-size: 1em;
}

/* ä»£ç å—ç‰¹æ®Šå¤„ç† */
.option-content pre,
.option-content code {
  background-color: #f5f5f5;
  padding: 2px 4px;
  border-radius: 3px;
  font-family: 'Courier New', monospace;
}
</style>
```

**3. KaTeXé›†æˆæ³¨æ„äº‹é¡¹**
- ç¡®ä¿KaTeXå…ƒç´ ä¸é˜»æ­¢çˆ¶å…ƒç´ äº‹ä»¶
- è®¾ç½®åˆé€‚çš„z-indexå±‚çº§
- åœ¨ç»„ä»¶mountedåæ‰§è¡ŒKaTeXæ¸²æŸ“

```javascript
mounted() {
  this.$nextTick(() => {
    // æ¸²æŸ“æ•°å­¦å…¬å¼
    this.renderMathFormulas()
    // ä¿®å¤é€‰é¡¹ç‚¹å‡»é—®é¢˜
    this.fixOptionClickability()
  })
},

methods: {
  fixOptionClickability() {
    // ç¡®ä¿æ‰€æœ‰é€‰é¡¹å†…å®¹ä¸é˜»æ­¢ç‚¹å‡»äº‹ä»¶
    const optionContents = this.$el.querySelectorAll('.option-content')
    optionContents.forEach(content => {
      content.style.pointerEvents = 'none'
    })
  }
}
```

### åˆ¤é¢˜é€»è¾‘é—®é¢˜

#### é€‰é¡¹æ ‡è¯†ç¬¦ä¸ä¸€è‡´
**é—®é¢˜**ï¼šæ–‡æ¡£ç¤ºä¾‹ä½¿ç”¨`option.id`ï¼Œä½†å®é™…ç³»ç»Ÿä½¿ç”¨`option.key`ï¼ˆAã€Bã€Cã€Dï¼‰ã€‚

**è§£å†³æ–¹æ¡ˆ**ï¼šç»Ÿä¸€ä½¿ç”¨`option.key`ä½œä¸ºé€‰é¡¹æ ‡è¯†ç¬¦ï¼š
```python
# åç«¯åˆ¤é¢˜é€»è¾‘
def judge_single_choice(self, question, selected_options):
    correct_options = [opt['key'] for opt in question.options if opt.get('is_correct')]
    if len(selected_options) != 1:
        return False, 0
    return selected_options[0] in correct_options, 1 if selected_options[0] in correct_options else 0
```

### æ€§èƒ½ä¼˜åŒ–é—®é¢˜

#### å¤æ‚å†…å®¹æ¸²æŸ“æ€§èƒ½
**é—®é¢˜**ï¼šåŒ…å«å¤§é‡æ•°å­¦å…¬å¼æˆ–ä»£ç çš„é¢˜ç›®æ¸²æŸ“ç¼“æ…¢ã€‚

**è§£å†³æ–¹æ¡ˆ**ï¼š
1. **æ‡’åŠ è½½æ¸²æŸ“**ï¼šåªæ¸²æŸ“å¯è§åŒºåŸŸçš„å†…å®¹
2. **ç¼“å­˜æ¸²æŸ“ç»“æœ**ï¼šå°†æ¸²æŸ“åçš„HTMLç¼“å­˜åˆ°localStorage
3. **åˆ†æ‰¹æ¸²æŸ“**ï¼šä½¿ç”¨requestAnimationFrameåˆ†æ‰¹å¤„ç†

```javascript
// æ‡’åŠ è½½æ¸²æŸ“ç¤ºä¾‹
methods: {
  async renderVisibleOptions() {
    const visibleOptions = this.getVisibleOptions()
    for (const option of visibleOptions) {
      await this.renderOptionContent(option)
    }
  },
  
  async renderOptionContent(option) {
    return new Promise(resolve => {
      requestAnimationFrame(() => {
        // æ¸²æŸ“KaTeXæˆ–ä»£ç é«˜äº®
        this.processComplexContent(option)
        resolve()
      })
    })
  }
}
```

## ğŸ§ª æµ‹è¯•ç”¨ä¾‹è¡¥å……

### å¤æ‚å†…å®¹é€‰é¡¹æµ‹è¯•
```javascript
// tests/unit/ChoiceQuestionDetail.spec.js
describe('å¤æ‚å†…å®¹é€‰é¡¹æµ‹è¯•', () => {
  it('åº”è¯¥æ­£ç¡®å¤„ç†åŒ…å«æ•°å­¦å…¬å¼çš„é€‰é¡¹ç‚¹å‡»', async () => {
    const question = {
      id: 1,
      question_type: 'single',
      options: [
        {
          key: 'A',
          content: 'å½“ <span class="katex">x = \\frac{1}{2}</span> æ—¶'
        },
        {
          key: 'B', 
          content: 'æ™®é€šé€‰é¡¹'
        }
      ]
    }
    
    const wrapper = mount(ChoiceQuestionDetail, {
      data() {
        return { question }
      }
    })
    
    // ç‚¹å‡»åŒ…å«KaTeXçš„é€‰é¡¹
    await wrapper.find('.option-row').trigger('click')
    
    expect(wrapper.vm.result.answer).toBe('A')
  })
  
  it('åº”è¯¥æ­£ç¡®å¤„ç†åŒ…å«ä»£ç å—çš„é€‰é¡¹ç‚¹å‡»', async () => {
    const question = {
      id: 1,
      question_type: 'multiple',
      options: [
        {
          key: 'A',
          content: 'ä»£ç ï¼š<code>console.log("hello")</code>'
        }
      ]
    }
    
    const wrapper = mount(ChoiceQuestionDetail, {
      data() {
        return { question, selectedOptions: [] }
      }
    })
    
    await wrapper.find('.option-row').trigger('click')
    
    expect(wrapper.vm.selectedOptions).toContain('A')
  })
  
  it('åº”è¯¥æ­£ç¡®å¤„ç†é€‰é¡¹å†…å®¹çš„pointer-eventsæ ·å¼', () => {
    const wrapper = mount(ChoiceQuestionDetail)
    
    const optionContent = wrapper.find('.option-content')
    const computedStyle = window.getComputedStyle(optionContent.element)
    
    expect(computedStyle.pointerEvents).toBe('none')
  })
})
```

### ç«¯åˆ°ç«¯æµ‹è¯•
```javascript
// tests/e2e/choice-question.spec.js
describe('é€‰æ‹©é¢˜ç«¯åˆ°ç«¯æµ‹è¯•', () => {
  it('åº”è¯¥èƒ½å¤Ÿæ­£å¸¸é€‰æ‹©åŒ…å«å¤æ‚å†…å®¹çš„é€‰é¡¹', () => {
    cy.visit('/choice-question/1')
    
    // ç­‰å¾…KaTeXæ¸²æŸ“å®Œæˆ
    cy.get('.katex').should('be.visible')
    
    // ç‚¹å‡»åŒ…å«æ•°å­¦å…¬å¼çš„é€‰é¡¹
    cy.get('.option-row').first().click()
    
    // éªŒè¯é€‰é¡¹è¢«é€‰ä¸­
    cy.get('.el-radio__input').first().should('have.class', 'is-checked')
    
    // æäº¤ç­”æ¡ˆ
    cy.get('button').contains('æäº¤ç­”æ¡ˆ').click()
    
    // éªŒè¯æäº¤æˆåŠŸ
    cy.get('.result-container').should('be.visible')
  })
})
```

## â“ å¸¸è§é—®é¢˜

### Q: å¦‚ä½•å¤„ç†å¤šé€‰é¢˜çš„éƒ¨åˆ†å¾—åˆ†ï¼Ÿ
A: å¤šé€‰é¢˜åˆ¤é¢˜æ—¶ï¼Œåªæœ‰é€‰æ‹©å®Œå…¨æ­£ç¡®æ‰èƒ½å¾—æ»¡åˆ†ï¼Œé€‰æ‹©éƒ¨åˆ†æ­£ç¡®ä¸”æ— é”™é€‰å¯å¾—éƒ¨åˆ†åˆ†æ•°ï¼Œæœ‰é”™é€‰åˆ™ä¸å¾—åˆ†ã€‚

### Q: é¢˜ç›®æ”¯æŒå“ªäº›æ ¼å¼çš„å¯¼å…¥ï¼Ÿ
A: æ”¯æŒExcelå’ŒCSVæ ¼å¼ï¼Œéœ€è¦æŒ‰ç…§æŒ‡å®šçš„æ¨¡æ¿æ ¼å¼å‡†å¤‡æ•°æ®ã€‚

### Q: å¦‚ä½•ä¼˜åŒ–å¤§é‡é¢˜ç›®çš„æŸ¥è¯¢æ€§èƒ½ï¼Ÿ
A: ä½¿ç”¨æ•°æ®åº“ç´¢å¼•ã€Redisç¼“å­˜ã€åˆ†é¡µæŸ¥è¯¢ç­‰æ–¹å¼ä¼˜åŒ–æ€§èƒ½ã€‚

### Q: é”™é¢˜æœ¬åŠŸèƒ½å¦‚ä½•å®ç°ï¼Ÿ
A: ç”¨æˆ·ç­”é”™é¢˜ç›®åè‡ªåŠ¨è®°å½•åˆ°é”™é¢˜æœ¬ï¼Œæ”¯æŒæŒ‰åˆ†ç±»ã€æ ‡ç­¾ç­‰ç»´åº¦ç­›é€‰å’Œå¤ä¹ ã€‚

### Q: é€‰é¡¹åŒ…å«æ•°å­¦å…¬å¼æ—¶æ— æ³•ç‚¹å‡»æ€ä¹ˆåŠï¼Ÿ
A: å‚è€ƒä¸Šè¿°"é€‰é¡¹å†…å®¹æ¸²æŸ“é—®é¢˜"è§£å†³æ–¹æ¡ˆï¼Œä¸»è¦é€šè¿‡CSSçš„pointer-eventså±æ€§å’Œåˆç†çš„DOMç»“æ„æ¥è§£å†³ã€‚

### Q: å¦‚ä½•è°ƒè¯•é€‰é¡¹ç‚¹å‡»é—®é¢˜ï¼Ÿ
A: 
1. æ£€æŸ¥æµè§ˆå™¨å¼€å‘è€…å·¥å…·ä¸­çš„äº‹ä»¶ç›‘å¬å™¨
2. éªŒè¯CSSçš„pointer-eventsè®¾ç½®
3. ç¡®è®¤DOMç»“æ„æ˜¯å¦æ­£ç¡®
4. æµ‹è¯•ä¸åŒç±»å‹å†…å®¹çš„é€‰é¡¹ï¼ˆçº¯æ–‡æœ¬ã€æ•°å­¦å…¬å¼ã€ä»£ç å—ï¼‰

---

## ğŸ“‹ æ›´æ–°æ—¥å¿—

### v1.1 (2025å¹´9æœˆ1æ—¥)
- **é‡å¤§æ›´æ–°**ï¼šæ·»åŠ äº†"å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ"ç« èŠ‚
- **å‰ç«¯å®ç°ä¼˜åŒ–**ï¼šæ›´æ–°äº†Vueç»„ä»¶ç¤ºä¾‹ï¼Œé‡‡ç”¨Element UIçš„Radio/Checkboxç»„ä»¶
- **é€‰é¡¹ç‚¹å‡»é—®é¢˜ä¿®å¤**ï¼šæä¾›äº†å®Œæ•´çš„è§£å†³æ–¹æ¡ˆå¤„ç†åŒ…å«KaTeXæ•°å­¦å…¬å¼å’Œä»£ç é«˜äº®çš„é€‰é¡¹
- **åˆ¤é¢˜é€»è¾‘ä¿®æ­£**ï¼šç»Ÿä¸€ä½¿ç”¨`option.key`ä½œä¸ºé€‰é¡¹æ ‡è¯†ç¬¦
- **æµ‹è¯•ç”¨ä¾‹è¡¥å……**ï¼šæ·»åŠ äº†å¤æ‚å†…å®¹é€‰é¡¹çš„å•å…ƒæµ‹è¯•å’Œç«¯åˆ°ç«¯æµ‹è¯•
- **æ€§èƒ½ä¼˜åŒ–æŒ‡å—**ï¼šæä¾›äº†å¤æ‚å†…å®¹æ¸²æŸ“çš„æ€§èƒ½ä¼˜åŒ–æ–¹æ¡ˆ

### v1.0 (2024å¹´1æœˆ)
- åˆå§‹ç‰ˆæœ¬å‘å¸ƒ
- åŸºç¡€åŠŸèƒ½æ–‡æ¡£å®Œæˆ

## ğŸš€ æ€§èƒ½ä¼˜åŒ–

### ç¼“å­˜ç­–ç•¥

#### Redisç¼“å­˜å®ç°
```python
from django.core.cache import cache
from django.conf import settings
import hashlib

class CachedChoiceQuestionJudge(ChoiceQuestionJudge):
    """å¸¦ç¼“å­˜çš„åˆ¤é¢˜ç±»"""
    
    def __init__(self):
        super().__init__()
        self.cache_timeout = getattr(settings, 'CHOICE_QUESTION_CACHE_TIMEOUT', 300)  # 5åˆ†é’Ÿ
    
    def get_cached_question(self, question_id: int) -> Optional[ChoiceQuestion]:
        """
        è·å–ç¼“å­˜çš„é¢˜ç›®
        
        Args:
            question_id: é¢˜ç›®ID
            
        Returns:
            é¢˜ç›®å¯¹è±¡æˆ–None
        """
        cache_key = f"choice_question:{question_id}"
        question = cache.get(cache_key)
        
        if question is None:
            try:
                question = ChoiceQuestion.objects.select_related('category').prefetch_related('tags').get(id=question_id)
                cache.set(cache_key, question, self.cache_timeout)
            except ChoiceQuestion.DoesNotExist:
                return None
        
        return question
    
    def get_cached_user_submissions(self, user_id: int, question_id: int) -> List[Dict]:
        """
        è·å–ç¼“å­˜çš„ç”¨æˆ·æäº¤è®°å½•
        
        Args:
            user_id: ç”¨æˆ·ID
            question_id: é¢˜ç›®ID
            
        Returns:
            æäº¤è®°å½•åˆ—è¡¨
        """
        cache_key = f"user_submissions:{user_id}:{question_id}"
        submissions = cache.get(cache_key)
        
        if submissions is None:
            submissions = list(ChoiceQuestionSubmission.objects.filter(
                user_id=user_id, question_id=question_id
            ).values('user_answer', 'is_correct', 'score', 'submit_time'))
            cache.set(cache_key, submissions, self.cache_timeout)
        
        return submissions
    
    def invalidate_question_cache(self, question_id: int):
        """
        æ¸…é™¤é¢˜ç›®ç›¸å…³ç¼“å­˜
        
        Args:
            question_id: é¢˜ç›®ID
        """
        cache_key = f"choice_question:{question_id}"
        cache.delete(cache_key)
        
        # æ¸…é™¤ç»Ÿè®¡ç¼“å­˜
        stats_key = f"question_stats:{question_id}"
        cache.delete(stats_key)
```

#### æ•°æ®åº“ä¼˜åŒ–
```python
# models/question.py ä¸­çš„ç´¢å¼•ä¼˜åŒ–
class ChoiceQuestion(models.Model):
    # ... å­—æ®µå®šä¹‰ ...
    
    class Meta:
        db_table = 'choice_question'
        indexes = [
            models.Index(fields=['visible', 'created_time']),  # åˆ—è¡¨æŸ¥è¯¢ä¼˜åŒ–
            models.Index(fields=['category', 'difficulty']),   # ç­›é€‰æŸ¥è¯¢ä¼˜åŒ–
            models.Index(fields=['created_by', 'visible']),    # ç®¡ç†å‘˜æŸ¥è¯¢ä¼˜åŒ–
            models.Index(fields=['question_type', 'difficulty']),  # ç±»å‹ç­›é€‰ä¼˜åŒ–
        ]
        ordering = ['-created_time']

# models/submission.py ä¸­çš„ç´¢å¼•ä¼˜åŒ–
class ChoiceQuestionSubmission(models.Model):
    # ... å­—æ®µå®šä¹‰ ...
    
    class Meta:
        db_table = 'choice_question_submission'
        indexes = [
            models.Index(fields=['user', 'question']),         # ç”¨æˆ·æäº¤æŸ¥è¯¢
            models.Index(fields=['question', 'is_correct']),   # ç»Ÿè®¡æŸ¥è¯¢ä¼˜åŒ–
            models.Index(fields=['user', 'submit_time']),      # ç”¨æˆ·å†å²æŸ¥è¯¢
            models.Index(fields=['submit_time']),              # æ—¶é—´æ’åºä¼˜åŒ–
        ]
        unique_together = [['user', 'question']]  # é˜²æ­¢é‡å¤æäº¤
```

### æ‰¹é‡æ“ä½œä¼˜åŒ–
```python
class BatchChoiceQuestionJudge:
    """æ‰¹é‡åˆ¤é¢˜ä¼˜åŒ–ç±»"""
    
    def __init__(self, batch_size: int = 100):
        self.batch_size = batch_size
        self.judge = ChoiceQuestionJudge()
    
    def batch_judge_with_optimization(self, submissions: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        ä¼˜åŒ–çš„æ‰¹é‡åˆ¤é¢˜
        
        Args:
            submissions: æäº¤åˆ—è¡¨
            
        Returns:
            åˆ¤é¢˜ç»“æœåˆ—è¡¨
        """
        results = []
        
        # æŒ‰æ‰¹æ¬¡å¤„ç†
        for i in range(0, len(submissions), self.batch_size):
            batch = submissions[i:i + self.batch_size]
            batch_results = self._process_batch(batch)
            results.extend(batch_results)
        
        return results
    
    def _process_batch(self, batch: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        å¤„ç†å•ä¸ªæ‰¹æ¬¡
        
        Args:
            batch: æ‰¹æ¬¡æäº¤åˆ—è¡¨
            
        Returns:
            æ‰¹æ¬¡ç»“æœåˆ—è¡¨
        """
        # é¢„åŠ è½½æ‰€æœ‰éœ€è¦çš„é¢˜ç›®
        question_ids = [sub['question_id'] for sub in batch]
        questions = {q.id: q for q in ChoiceQuestion.objects.filter(id__in=question_ids)}
        
        results = []
        submissions_to_save = []
        
        for submission in batch:
            question_id = submission['question_id']
            question = questions.get(question_id)
            
            if not question:
                results.append({
                    'is_correct': False,
                    'score': 0,
                    'error': 'QUESTION_NOT_EXIST',
                    'question_id': question_id
                })
                continue
            
            # æ‰§è¡Œåˆ¤é¢˜
            result = self.judge.judge_submission(
                question, 
                submission['user_answer'], 
                submission.get('user'),
                save_submission=False  # æ‰¹é‡ä¿å­˜
            )
            
            results.append(result)
            
            # å‡†å¤‡æ‰¹é‡ä¿å­˜çš„æ•°æ®
            if submission.get('user') and result.get('is_correct') is not None:
                submissions_to_save.append({
                    'user': submission['user'],
                    'question': question,
                    'user_answer': result['user_answer'],
                    'is_correct': result['is_correct'],
                    'score': result['score']
                })
        
        # æ‰¹é‡ä¿å­˜æäº¤è®°å½•
        if submissions_to_save:
            self._batch_save_submissions(submissions_to_save)
        
        return results
```

### å¹¶å‘å¤„ç†
```python
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed

class ConcurrentChoiceQuestionJudge:
    """å¹¶å‘åˆ¤é¢˜ç±»"""
    
    def __init__(self, max_workers: int = 4):
        self.max_workers = max_workers
        self.judge = ChoiceQuestionJudge()
        self._lock = threading.Lock()
    
    def concurrent_judge(self, submissions: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        å¹¶å‘åˆ¤é¢˜
        
        Args:
            submissions: æäº¤åˆ—è¡¨
            
        Returns:
            åˆ¤é¢˜ç»“æœåˆ—è¡¨
        """
        results = [None] * len(submissions)
        
        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            # æäº¤ä»»åŠ¡
            future_to_index = {
                executor.submit(self._judge_single, sub): i 
                for i, sub in enumerate(submissions)
            }
            
            # æ”¶é›†ç»“æœ
            for future in as_completed(future_to_index):
                index = future_to_index[future]
                try:
                    results[index] = future.result()
                except Exception as e:
                    results[index] = {
                        'is_correct': False,
                        'score': 0,
                        'error': 'CONCURRENT_ERROR',
                        'message': str(e)
                    }
        
        return results
```

## ğŸ“Š ç›‘æ§ä¸æ—¥å¿—

### åˆ¤é¢˜æ—¥å¿—ç³»ç»Ÿ
```python
import logging
import time
from functools import wraps

# é…ç½®æ—¥å¿—
logger = logging.getLogger('choice_question.judge')
performance_logger = logging.getLogger('choice_question.performance')
error_logger = logging.getLogger('choice_question.error')

def log_judge_performance(func):
    """åˆ¤é¢˜æ€§èƒ½æ—¥å¿—è£…é¥°å™¨"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        
        try:
            result = func(*args, **kwargs)
            end_time = time.time()
            duration = end_time - start_time
            
            # è®°å½•æ€§èƒ½æ—¥å¿—
            performance_logger.info(f"Judge completed: {func.__name__}, duration={duration:.3f}s")
            
            # å¦‚æœè€—æ—¶è¿‡é•¿ï¼Œè®°å½•è­¦å‘Š
            if duration > 1.0:  # è¶…è¿‡1ç§’
                performance_logger.warning(f"Slow judge: {func.__name__}, duration={duration:.3f}s")
            
            return result
            
        except Exception as e:
            end_time = time.time()
            duration = end_time - start_time
            
            # è®°å½•é”™è¯¯æ—¥å¿—
            error_logger.error(f"Judge failed: {func.__name__}, duration={duration:.3f}s, error={str(e)}")
            raise
    
    return wrapper

class JudgeMetrics:
    """åˆ¤é¢˜æŒ‡æ ‡æ”¶é›†ç±»"""
    
    def __init__(self):
        self.total_judges = 0
        self.successful_judges = 0
        self.failed_judges = 0
        self.total_time = 0.0
        self.max_time = 0.0
        self.min_time = float('inf')
    
    def record_judge(self, duration: float, success: bool):
        """
        è®°å½•åˆ¤é¢˜æŒ‡æ ‡
        
        Args:
            duration: åˆ¤é¢˜è€—æ—¶
            success: æ˜¯å¦æˆåŠŸ
        """
        self.total_judges += 1
        self.total_time += duration
        
        if success:
            self.successful_judges += 1
        else:
            self.failed_judges += 1
        
        self.max_time = max(self.max_time, duration)
        self.min_time = min(self.min_time, duration)
    
    def get_statistics(self) -> Dict[str, Any]:
        """
        è·å–ç»Ÿè®¡ä¿¡æ¯
        
        Returns:
            ç»Ÿè®¡æ•°æ®
        """
        if self.total_judges == 0:
            return {
                'total_judges': 0,
                'success_rate': 0.0,
                'average_time': 0.0,
                'max_time': 0.0,
                'min_time': 0.0
            }
        
        return {
            'total_judges': self.total_judges,
            'successful_judges': self.successful_judges,
            'failed_judges': self.failed_judges,
            'success_rate': self.successful_judges / self.total_judges,
            'average_time': self.total_time / self.total_judges,
            'max_time': self.max_time,
            'min_time': self.min_time if self.min_time != float('inf') else 0.0
        }

# å…¨å±€æŒ‡æ ‡æ”¶é›†å™¨
judge_metrics = JudgeMetrics()
```

### å¥åº·æ£€æŸ¥æ¥å£
```python
# views/health.py
from django.http import JsonResponse
from django.views import View
from ..utils.judge import judge_metrics

class JudgeHealthView(View):
    """åˆ¤é¢˜ç³»ç»Ÿå¥åº·æ£€æŸ¥æ¥å£"""
    
    def get(self, request):
        """
        è·å–åˆ¤é¢˜ç³»ç»Ÿå¥åº·çŠ¶æ€
        
        Returns:
            å¥åº·çŠ¶æ€æ•°æ®
        """
        try:
            # è·å–åˆ¤é¢˜ç»Ÿè®¡
            stats = judge_metrics.get_statistics()
            
            # æ£€æŸ¥æ•°æ®åº“è¿æ¥
            from ..models import ChoiceQuestion
            question_count = ChoiceQuestion.objects.count()
            
            # æ£€æŸ¥ç¼“å­˜
            from django.core.cache import cache
            cache_status = 'ok'
            try:
                cache.set('health_check', 'ok', 10)
                if cache.get('health_check') != 'ok':
                    cache_status = 'error'
            except Exception:
                cache_status = 'error'
            
            return JsonResponse({
                'status': 'healthy',
                'timestamp': timezone.now().isoformat(),
                'judge_statistics': stats,
                'database': {
                    'status': 'ok',
                    'question_count': question_count
                },
                'cache': {
                    'status': cache_status
                }
            })
            
        except Exception as e:
            return JsonResponse({
                'status': 'unhealthy',
                'timestamp': timezone.now().isoformat(),
                'error': str(e)
            }, status=500)
```

### é”™è¯¯å¤„ç†æœºåˆ¶
```python
class ChoiceQuestionException(Exception):
    """é€‰æ‹©é¢˜ç›¸å…³å¼‚å¸¸åŸºç±»"""
    pass

class InvalidAnswerFormatException(ChoiceQuestionException):
    """ç­”æ¡ˆæ ¼å¼é”™è¯¯å¼‚å¸¸"""
    pass

class QuestionNotExistException(ChoiceQuestionException):
    """é¢˜ç›®ä¸å­˜åœ¨å¼‚å¸¸"""
    pass

class DuplicateSubmissionException(ChoiceQuestionException):
    """é‡å¤æäº¤å¼‚å¸¸"""
    pass

## ğŸ”„ æ··åˆé¢˜å‹åˆ¤é¢˜ç³»ç»Ÿå®ç°

### åˆ¤é¢˜è°ƒåº¦å™¨æ ¸å¿ƒå®ç°

```python
from django.conf import settings
from judge.tasks import judge_task
from .models import ChoiceQuestion, ChoiceQuestionSubmission
from problem.models import Problem
from submission.models import Submission

class JudgeDispatcher:
    """ç»Ÿä¸€åˆ¤é¢˜è°ƒåº¦å™¨"""
    
    @staticmethod
    def dispatch_judge(submission_data):
        """
        æ ¹æ®é¢˜ç›®ç±»å‹åˆ†å‘åˆ¤é¢˜ä»»åŠ¡
        
        Args:
            submission_data: æäº¤æ•°æ®
            {
                'problem_id': int,
                'user_id': int,
                'code': str,  # ç¼–ç¨‹é¢˜ä»£ç æˆ–é€‰æ‹©é¢˜ç­”æ¡ˆ
                'language': str,  # ç¼–ç¨‹é¢˜è¯­è¨€æˆ–'choice'
                'contest_id': int,  # å¯é€‰
            }
        
        Returns:
            åˆ¤é¢˜ç»“æœ
        """
        problem_id = submission_data['problem_id']
        
        # é¢˜ç›®ç±»å‹è¯†åˆ«
        question_type = QuestionTypeDetector.detect_type(problem_id)
        
        if question_type == 'choice':
            # é€‰æ‹©é¢˜åˆ¤é¢˜
            return ChoiceQuestionJudgeDispatcher.judge(submission_data)
        elif question_type == 'programming':
            # ç¼–ç¨‹é¢˜åˆ¤é¢˜ï¼ˆå¤ç”¨åŸç³»ç»Ÿï¼‰
            return ProgrammingQuestionJudgeDispatcher.judge(submission_data)
        else:
            raise ValueError(f"Unknown question type: {question_type}")

class QuestionTypeDetector:
    """é¢˜ç›®ç±»å‹è¯†åˆ«å™¨"""
    
    @staticmethod
    def detect_type(problem_id):
        """
        è¯†åˆ«é¢˜ç›®ç±»å‹
        
        Args:
            problem_id: é¢˜ç›®ID
            
        Returns:
            'choice' | 'programming'
        """
        # æ£€æŸ¥æ˜¯å¦ä¸ºé€‰æ‹©é¢˜
        if ChoiceQuestion.objects.filter(problem_id=problem_id).exists():
            return 'choice'
        
        # æ£€æŸ¥æ˜¯å¦ä¸ºç¼–ç¨‹é¢˜
        if Problem.objects.filter(id=problem_id).exists():
            return 'programming'
        
        raise ValueError(f"Problem {problem_id} not found")

class ChoiceQuestionJudgeDispatcher:
    """é€‰æ‹©é¢˜åˆ¤é¢˜åˆ†å‘å™¨"""
    
    @staticmethod
    def judge(submission_data):
        """
        é€‰æ‹©é¢˜åˆ¤é¢˜å¤„ç†
        
        Args:
            submission_data: æäº¤æ•°æ®
            
        Returns:
            åˆ¤é¢˜ç»“æœ
        """
        from .utils.judge import ChoiceQuestionJudge
        
        problem_id = submission_data['problem_id']
        user_id = submission_data['user_id']
        answer = submission_data['code']  # é€‰æ‹©é¢˜ç­”æ¡ˆ
        contest_id = submission_data.get('contest_id')
        
        # è·å–é€‰æ‹©é¢˜
        try:
            choice_question = ChoiceQuestion.objects.get(problem_id=problem_id)
        except ChoiceQuestion.DoesNotExist:
            raise QuestionNotExistException(f"Choice question {problem_id} not found")
        
        # æ‰§è¡Œåˆ¤é¢˜
        judge = ChoiceQuestionJudge()
        result = judge.judge(choice_question, answer, user_id)
        
        # åˆ›å»ºæäº¤è®°å½•
        submission = ChoiceQuestionSubmission.objects.create(
            user_id=user_id,
            question=choice_question,
            answer=answer,
            result=result['result'],
            score=result['score'],
            contest_id=contest_id
        )
        
        # ç»Ÿä¸€ç»“æœå¤„ç†
        ResultProcessor.process_choice_result(submission, result)
        
        return {
            'submission_id': submission.id,
            'result': result['result'],
            'score': result['score'],
            'info': result.get('info', {})
        }

class ProgrammingQuestionJudgeDispatcher:
    """ç¼–ç¨‹é¢˜åˆ¤é¢˜åˆ†å‘å™¨"""
    
    @staticmethod
    def judge(submission_data):
        """
        ç¼–ç¨‹é¢˜åˆ¤é¢˜å¤„ç†ï¼ˆå¤ç”¨åŸç³»ç»Ÿï¼‰
        
        Args:
            submission_data: æäº¤æ•°æ®
            
        Returns:
            åˆ¤é¢˜ç»“æœ
        """
        # åˆ›å»ºç¼–ç¨‹é¢˜æäº¤è®°å½•
        submission = Submission.objects.create(
            problem_id=submission_data['problem_id'],
            user_id=submission_data['user_id'],
            code=submission_data['code'],
            language=submission_data['language'],
            contest_id=submission_data.get('contest_id')
        )
        
        # è°ƒç”¨åŸæœ‰åˆ¤é¢˜ç³»ç»Ÿ
        judge_task.delay(submission.id, submission.problem_id)
        
        return {
            'submission_id': submission.id,
            'result': 'Pending',  # å¼‚æ­¥åˆ¤é¢˜
            'info': {'message': 'Submission queued for judging'}
        }

class ResultProcessor:
    """ç»Ÿä¸€ç»“æœå¤„ç†å™¨"""
    
    @staticmethod
    def process_choice_result(submission, result):
        """
        å¤„ç†é€‰æ‹©é¢˜åˆ¤é¢˜ç»“æœ
        
        Args:
            submission: é€‰æ‹©é¢˜æäº¤è®°å½•
            result: åˆ¤é¢˜ç»“æœ
        """
        # æ›´æ–°ç”¨æˆ·ç»Ÿè®¡
        SubmissionManager.update_user_statistics(
            user_id=submission.user_id,
            question_type='choice',
            result=result['result'],
            score=result['score']
        )
        
        # æ›´æ–°ç«èµ›æ’åï¼ˆå¦‚æœæ˜¯ç«èµ›é¢˜ç›®ï¼‰
        if submission.contest_id:
            SubmissionManager.update_contest_ranking(
                contest_id=submission.contest_id,
                user_id=submission.user_id,
                submission=submission
            )
        
        # é”™é¢˜è®°å½•
        if result['result'] != 'Accepted':
            SubmissionManager.add_to_wrong_question_book(
                user_id=submission.user_id,
                question=submission.question
            )

class SubmissionManager:
    """æäº¤è®°å½•ç»Ÿä¸€ç®¡ç†"""
    
    @staticmethod
    def update_user_statistics(user_id, question_type, result, score):
        """
        æ›´æ–°ç”¨æˆ·ç»Ÿè®¡ä¿¡æ¯
        
        Args:
            user_id: ç”¨æˆ·ID
            question_type: é¢˜ç›®ç±»å‹ ('choice' | 'programming')
            result: åˆ¤é¢˜ç»“æœ
            score: å¾—åˆ†
        """
        from account.models import UserProfile
        
        try:
            profile = UserProfile.objects.get(user_id=user_id)
            
            if question_type == 'choice':
                # æ›´æ–°é€‰æ‹©é¢˜ç»Ÿè®¡
                profile.choice_submission_number = models.F('choice_submission_number') + 1
                if result == 'Accepted':
                    profile.choice_accepted_number = models.F('choice_accepted_number') + 1
            
            profile.save(update_fields=[
                'choice_submission_number', 'choice_accepted_number'
            ])
            
        except UserProfile.DoesNotExist:
            pass
    
    @staticmethod
    def update_contest_ranking(contest_id, user_id, submission):
        """
        æ›´æ–°ç«èµ›æ’å
        
        Args:
            contest_id: ç«èµ›ID
            user_id: ç”¨æˆ·ID
            submission: æäº¤è®°å½•
        """
        from contest.models import ContestRank
        
        # è·å–æˆ–åˆ›å»ºç«èµ›æ’åè®°å½•
        rank, created = ContestRank.objects.get_or_create(
            contest_id=contest_id,
            user_id=user_id
        )
        
        # æ›´æ–°æ’åä¿¡æ¯ï¼ˆæ ¹æ®é¢˜ç›®ç±»å‹ï¼‰
        if hasattr(submission, 'question'):  # é€‰æ‹©é¢˜
            problem_id = submission.question.problem_id
        else:  # ç¼–ç¨‹é¢˜
            problem_id = submission.problem_id
        
        # æ›´æ–°æäº¤ä¿¡æ¯
        rank.update_submission_info(problem_id, submission)
    
    @staticmethod
    def add_to_wrong_question_book(user_id, question):
        """
        æ·»åŠ åˆ°é”™é¢˜æœ¬
        
        Args:
            user_id: ç”¨æˆ·ID
            question: é¢˜ç›®å¯¹è±¡
        """
        from .models import WrongQuestionBook
        
        WrongQuestionBook.objects.get_or_create(
            user_id=user_id,
            question=question,
            defaults={'created_time': timezone.now()}
        )
```

### ç»Ÿä¸€APIæ¥å£

```python
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from utils.api import APIError, validate_serializer

class UnifiedSubmissionAPI(APIView):
    """ç»Ÿä¸€æäº¤æ¥å£"""
    
    def post(self, request):
        """
        ç»Ÿä¸€é¢˜ç›®æäº¤æ¥å£
        
        æ”¯æŒç¼–ç¨‹é¢˜å’Œé€‰æ‹©é¢˜çš„ç»Ÿä¸€æäº¤
        """
        data = request.data
        
        # å‚æ•°éªŒè¯
        required_fields = ['problem_id', 'code']
        for field in required_fields:
            if field not in data:
                return APIError.error(f"Missing required field: {field}")
        
        try:
            # æ„å»ºæäº¤æ•°æ®
            submission_data = {
                'problem_id': data['problem_id'],
                'user_id': request.user.id,
                'code': data['code'],
                'language': data.get('language', 'choice'),
                'contest_id': data.get('contest_id')
            }
            
            # è°ƒç”¨åˆ¤é¢˜è°ƒåº¦å™¨
            result = JudgeDispatcher.dispatch_judge(submission_data)
            
            return Response({
                'error': None,
                'data': result
            })
            
        except Exception as e:
            return APIError.error(str(e))

class UnifiedSubmissionListAPI(APIView):
    """ç»Ÿä¸€æäº¤è®°å½•æ¥å£"""
    
    def get(self, request):
        """
        è·å–ç”¨æˆ·æäº¤è®°å½•ï¼ˆåŒ…å«ç¼–ç¨‹é¢˜å’Œé€‰æ‹©é¢˜ï¼‰
        """
        user_id = request.user.id
        page = int(request.GET.get('page', 1))
        limit = int(request.GET.get('limit', 20))
        
        # è·å–ç¼–ç¨‹é¢˜æäº¤
        programming_submissions = Submission.objects.filter(
            user_id=user_id
        ).values(
            'id', 'problem_id', 'result', 'create_time',
            'language', 'code'
        ).annotate(
            submission_type=models.Value('programming', output_field=models.CharField())
        )
        
        # è·å–é€‰æ‹©é¢˜æäº¤
        choice_submissions = ChoiceQuestionSubmission.objects.filter(
            user_id=user_id
        ).values(
            'id', 'question__problem_id', 'result', 'create_time',
            'answer'
        ).annotate(
            submission_type=models.Value('choice', output_field=models.CharField()),
            problem_id=models.F('question__problem_id'),
            language=models.Value('choice', output_field=models.CharField()),
            code=models.F('answer')
        )
        
        # åˆå¹¶å¹¶æ’åº
        from django.db.models import Q
        from itertools import chain
        
        all_submissions = sorted(
            chain(programming_submissions, choice_submissions),
            key=lambda x: x['create_time'],
            reverse=True
        )
        
        # åˆ†é¡µ
        start = (page - 1) * limit
        end = start + limit
        submissions = all_submissions[start:end]
        
        return Response({
            'error': None,
            'data': {
                'results': submissions,
                'total': len(all_submissions)
            }
        })
```

### å‰ç«¯ç»Ÿä¸€å¤„ç†

```javascript
// api/submission.js
import api from '@/utils/api'

export default {
  // ç»Ÿä¸€æäº¤æ¥å£
  submitAnswer(problemId, code, language = 'choice', contestId = null) {
    return api.post('/api/submission/unified/', {
      problem_id: problemId,
      code: code,
      language: language,
      contest_id: contestId
    })
  },
  
  // ç»Ÿä¸€æäº¤è®°å½•
  getSubmissions(page = 1, limit = 20) {
    return api.get('/api/submission/unified/', {
      params: { page, limit }
    })
  }
}

// ä½¿ç”¨ç¤ºä¾‹
// é€‰æ‹©é¢˜æäº¤
submissionAPI.submitAnswer(123, JSON.stringify(['A', 'C']), 'choice')

// ç¼–ç¨‹é¢˜æäº¤  
submissionAPI.submitAnswer(456, codeContent, 'cpp')
```

def handle_judge_errors(func):
    """åˆ¤é¢˜é”™è¯¯å¤„ç†è£…é¥°å™¨"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except InvalidAnswerFormatException as e:
            logger.warning(f"Invalid answer format: {str(e)}")
            return {
                'is_correct': False,
                'score': 0,
                'error': 'INVALID_ANSWER_FORMAT',
                'message': 'ç­”æ¡ˆæ ¼å¼é”™è¯¯'
            }
        except QuestionNotExistException as e:
            logger.error(f"Question not exist: {str(e)}")
            return {
                'is_correct': False,
                'score': 0,
                'error': 'QUESTION_NOT_EXIST',
                'message': 'é¢˜ç›®ä¸å­˜åœ¨'
            }
        except Exception as e:
            logger.error(f"Unexpected judge error: {str(e)}")
            return {
                'is_correct': False,
                'score': 0,
                'error': 'SYSTEM_ERROR',
                'message': 'ç³»ç»Ÿé”™è¯¯ï¼Œè¯·è”ç³»ç®¡ç†å‘˜'
            }
    return wrapper
```

---

## ğŸ“ æ›´æ–°æ—¥å¿—

### v1.3 (2025å¹´1æœˆ21æ—¥)
- âœ¨ **æ–°å¢æ··åˆé¢˜å‹åˆ¤é¢˜ç³»ç»Ÿè®¾è®¡**
  - æ·»åŠ ç»Ÿä¸€åˆ¤é¢˜è°ƒåº¦å™¨æ¶æ„
  - å®ç°é¢˜ç›®ç±»å‹è‡ªåŠ¨è¯†åˆ«æœºåˆ¶
  - æä¾›ç¼–ç¨‹é¢˜ä¸é€‰æ‹©é¢˜ååŒåˆ¤é¢˜æ–¹æ¡ˆ
  - ç»Ÿä¸€æäº¤è®°å½•å’Œç»“æœå¤„ç†æµç¨‹
- ğŸ”§ **ç³»ç»Ÿæ¶æ„ä¼˜åŒ–**
  - æ¨¡å—åŒ–åˆ¤é¢˜å¼•æ“è®¾è®¡
  - ç»Ÿä¸€APIæ¥å£è§„èŒƒ
  - å‰ç«¯ç»Ÿä¸€å¤„ç†æ–¹æ¡ˆ
- ğŸ“š **æ–‡æ¡£å®Œå–„**
  - è¯¦ç»†çš„å®ç°ä»£ç ç¤ºä¾‹
  - å®Œæ•´çš„ç³»ç»Ÿç»„ä»¶è¯´æ˜
  - å‰åç«¯é›†æˆæŒ‡å—

### v1.2 (2025å¹´9æœˆ1æ—¥)
- ğŸš€ **æ€§èƒ½ä¼˜åŒ–ä¸ç›‘æ§**
  - Redisç¼“å­˜ç­–ç•¥å®ç°
  - æ•°æ®åº“ç´¢å¼•ä¼˜åŒ–
  - æ‰¹é‡æ“ä½œå’Œå¹¶å‘å¤„ç†
  - åˆ¤é¢˜æ—¥å¿—å’Œå¥åº·æ£€æŸ¥ç³»ç»Ÿ
- ğŸ›¡ï¸ **é”™è¯¯å¤„ç†æœºåˆ¶**
  - è‡ªå®šä¹‰å¼‚å¸¸ç±»å‹
  - ç»Ÿä¸€é”™è¯¯å¤„ç†è£…é¥°å™¨
  - å®Œå–„çš„å¼‚å¸¸æ•è·å’Œæ—¥å¿—è®°å½•

### v1.1 (2025å¹´8æœˆ15æ—¥)
- ğŸ“Š **æ•°æ®æ¨¡å‹æ‰©å±•**
  - é€‰æ‹©é¢˜åˆ†ç±»å’Œæ ‡ç­¾ç³»ç»Ÿ
  - é”™é¢˜æœ¬åŠŸèƒ½
  - ç»Ÿè®¡åˆ†ææ¨¡å‹
- ğŸ¨ **å‰ç«¯åŠŸèƒ½å¢å¼º**
  - å¯Œæ–‡æœ¬ç¼–è¾‘å™¨é›†æˆ
  - åˆ†ç±»ç®¡ç†ç•Œé¢
  - é¢˜ç›®ç­›é€‰å’Œæœç´¢

### v1.0 (2025å¹´7æœˆ1æ—¥)
- ğŸ‰ **åˆå§‹ç‰ˆæœ¬å‘å¸ƒ**
  - åŸºç¡€é€‰æ‹©é¢˜åˆ¤é¢˜åŠŸèƒ½
  - å•é€‰/å¤šé€‰é¢˜æ”¯æŒ
  - åŸºæœ¬çš„APIæ¥å£
  - å‰ç«¯å±•ç¤ºç»„ä»¶

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.3  
**æœ€åæ›´æ–°**: 2025å¹´9æœˆ1æ—¥19:53:29  
**ç»´æŠ¤è€…**: MetaSeekOJå¼€å‘å›¢é˜Ÿ  
**ä¸»è¦è´¡çŒ®è€…**: åŸºäºå®é™…å¼€å‘ä¸­é‡åˆ°çš„é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆè¿›è¡Œæ–‡æ¡£å®Œå–„